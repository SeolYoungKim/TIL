### Join

Join이란 두개 이상의 테이블을 묶어서 하나의 결과 집합을 만들어내는 것입니다.

Join에는 크게 Outer join과 Inner Join이 있습니다.

Outer Join부터 설명드리자면,
서로 연관 관계가 있는 엔티티 간에,  FK가 할당되지 않은 엔티티여도 대상 테이블에 있는 데이터를 전부 가져오는 방식입니다.

Outer Join은 left join과 right join으로 나뉘는데, 이는 왼쪽 테이블을 대상으로 할것인지, 오른쪽 테이블을 대상으로 할것인지에 대한 차이 입니다.

InnerJoin은 교집합입니다. 그렇기 때문에, FK가 할당되어 있는 엔티티만 가져옵니다.

### SQL injection

조작된 SQL 쿼리문을 날려 DB에 그대로 전달해 비정상적 명령을 실행시키는 공격 기법입니다.

인풋 값에 대한 특수문자 여부 검사, SQL 서버 오류 메세지 감추기 등을 이용하여 공격을 방어할 수 있습니다.

### SQL vs NoSQL

SQL은 관계형 데이터베이스에서 데이터를 관리하기 위해 사용하는 프로그래밍 언어입니다.

관계형 DB의 대표적인 특징으로는, 정해진 데이터 스키마에 따라 테이블이 저장되고, 관계를 통해 여러 테이블에 분산할 수 있다는 점이 있습니다. 이는 정의된 구조에 따라서만 넣을 수 있다는 뜻이며, DB의 중복을 피하기 위해 관계를 이용합니다.

NoSQL은 SQL을 사용하지 않는 DB 관리 시스템을 말합니다. 이를 이용하여 여러 유형의 DB를 사용할 수 있습니다.

### ORM

ORM이란, 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑해주는 기술입니다. 객체를 구현한 클래스와 RDB의 테이블을 자동으로 매핑해줍니다.

객체와 DB는 서로 패러다임 불일치가 있습니다. 이것을 ORM을 통해 객체 간 관계를 바탕으로, SQL문을 자동으로 생성하여 불일치를 해결해줍니다. ORM을 사용하면, SQL을 작성할 필요 없이, 객체를 통해 간접적으로 DB를 조작할 수 있게 됩니다.

자바 진영의 대표적인 ORM은 JPA가 있고, 그 구현체로는 Hibernate가 있습니다.

### 정규화

아직은, 수행해본 경험이 없어서 설명이 와닿질 않아 개념만 이해하고 있는 수준입니다. 정규화는 데이터의 중복을 줄이고, 무결성을 향상시키기 위해 테이블을 분리하는 것을 말합니다.

### 반 정규화

DB의 성능 향상을 위해 DB 중복을 허용하고, Join을 줄이는 방법입니다. 조회 속도가 향상되지만, 모델 유연성은 낮아진다고 합니다. 이 또한 개념만 이해하고 있는 수준입니다.

### DB의 뷰

가상의 테이블로, 진짜 테이블에 링크된 개념입니다.
뷰를 통해 보완에 도움이 되고, 복잡한 쿼리를 줄여줄 수 있으나 정의된 뷰를 일부만 변경할 수 없다는 단점이 있습니다. 이 때문에, 데이터 조작 시 제한 사항이 많으며, 뷰만의 독립적인 인덱스를 가질 수 없습니다.

한번도 사용해본적은 없지만, 프록시랑 비슷한 개념인 것 같습니다.

### 인덱스

데이터의 주소값을 저장하는 특별한 자료구조입니다. 추가적인 쓰기 작업과 저장 공간을 활용하여 DB 테이블의 검색 속도를 향상시킵니다.

특정 컬럼에 대한 Index가 존재한다면, 쿼리 수행 시 테이블 전체를 탐색하지 않고, 해당 Index를 바탕으로 원하는 데이터의 위치를 빠르게 검색할 수 있습니다.

### 트랜잭션

트랜잭션은 DB의 상태를 변화시키기 위해 수행하는 일련의 작업 단위입니다. 트랜잭션은 데이터의 유효성을 보장하기 위해, ACID라는 속성을 가지고 있습니다.

**원자성** : 각 트랜잭션의 단일 단위 처리를 보장합니다.

**일관성** : 모든 트랜잭션이 일관성있는 DB 상태를 유지하도록 합니다. DB의 무결성 제약 조건을 만족해야 합니다. (FK-PK 간의 관계 보장)

**격리성** : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치지 않아야 합니다. 동시성을 제어합니다. 격리 수준은 4가지가 있는데, 커밋되지 않은 읽기, 커밋된 읽기, 반복 가능한 읽기, 직렬화 가능이 있습니다.

**내구성** : 트랜잭션을 성공적으로 끝내면 결과가 항상 기록돼야 합니다. 시스템 문제가 발생하더라도, DB 로그를 사용해서 성공한 트랜잭션 내용을 복구합니다.

### 트랜잭션의 상태

- 활동 : 트랜잭션이 실행 중
- 실패 : 트랜잭션 실행에 오류가 발생하여 중단된 상태
- 철회 : 트랜잭션이 비정상적으로 종료하여 롤백된 상태
- 부분 완료 : 트랜잭션이 마지막 연산까지 수행했으나, 커밋이 실행되기 직전의 상태
- 완료 : 트랜잭션이 성공적으로 종료되어 커밋을 수행한 상태

### 트랜잭션 격리 수준

**참고 |** [https://steady-coding.tistory.com/562](https://steady-coding.tistory.com/562)

동시에 여러 트랜잭션이 처리될 때, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것.

- 커밋되지 않은 읽기
    - 한 트랜잭션의 변경된 내용을 커밋이나 롤백과 상관 없이 다른 트랜잭션에서 읽을 수 있는 격리 수준
    - 모든 부정합 문제 발생
- 커밋된 읽기
    - COMMIT이 완료된 데이터만 조회 가능한 격리 수준
    - 더티 리드 해결
- 반복 가능한 읽기
    - 트랜잭션이 시작되기 전에 커밋된 내용에 관해서만 조회할 수 있는 격리 수준
    - NON-REPEATABLE-READ 해결
    - InnoDB에서는 PHANTOM READ 해결
- 직렬화
    - 한 트랜잭션을 다른 트랜잭션으로부터 완전히 분리하는 격리 수준
    - 모든 부정합 문제 해결

- 부정합 문제 (심화)
    - 더티 리드 : 다른 트랜잭션에서 처리한 작업이 완료되지 않았음에도 불구하고 다른 트랜잭션에서 볼 수 있는 현상
    - Non-repeatable read : 하나의 트랜잭션 내에서 동일한 select 쿼리를 실행했을 때, 항상 같은 결과를 보장해야 한다는 repeatable read 정합성에 어긋나는 것
    - phantom read : 쓰기 잠금을 거는 경우, 다른 트랜잭션에서 수행한 변경 작업에 의해 레코드가 안보였다가 보였다가 하는 현상

### 트리거

테이블에 부착되어 테이블에 insert, update, delete 작업이 발생되면 자동으로 실행되는 코드.
무결성 보장, 업무 규칙 보장, 업무 처리 자동화.
