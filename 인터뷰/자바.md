# 3. 스프링 기본

### @SpringBootApplication?

스프링 부트로 프로젝트를 시작하면, `XxxApplication` 이라는 클래스를 만드는데, 이러한 Application 클래스에 사용되는 애노테이션입니다.

해당 애노테이션을 살펴보면, `@ComponentScan`, `@EnableAutoConfiguration`이라는 부가적인 애노테이션이 붙어있는 것을 확인할 수 있습니다.

이 두 애노테이션을 통해서, 스프링부트의 Bean을 읽어와서 자동으로 등록 및 생성해주는 역할을 합니다.

자세히 말씀드리자면, `@ComponentScan`은 `@Component`가 붙어있는 클래스는 전부 빈으로 등록합니다. (리포지토리나 서비스, 컨트롤러 애너테이션은 기본적으로 @Component가 붙어있습니다.)

그리고, @SpringBootApplication은 해당 위치부터 설정을 읽어나가기 때문에, 반드시 프로젝트의 최상단에 위치해야 합니다.

마지막으로, 해당 애너테이션이 붙은 클래스의 main 메서드에있는 `SpringApplication.run()`을 실행하면 내장 WAS를 실행하게 됩니다.

### DI의 과정

의존성 주입이라는 개념입니다. 스프링부트는 @Component가 붙어있거나, @Configuration이 붙은 클래스 내의 @Bean들을 빈으로 등록합니다. 그 후, 각 스프링 빈들의 의존관계를 파악하여 의존성을 주입해줍니다. (IoC의 일종이다.)

### IoC

제어의 역전을 의미합니다. 메서드나 객체의 호출 작업을 개발자가 하는게 아닌, 외부에서 결정 되는 것을 의미합니다.

클래스를 빈으로 등록함으로써 스프링 IoC 컨테이너에 등록합니다. 제어를 위임함으로써, 빈의 생성부터 소멸까지를 스프링이 관리해줍니다.

### 서블릿

- 자바 표준 중 하나. 서버에서 동작하는 클래스들을 의미.
- init(), service(), destroy() 3개 메서드 정의 필수
- 싱글톤으로 관리됨.

### 서블릿 컨테이너

- 서블릿을 관리해주는 컨테이너. Client의 요청을 받고, 응답을 해줄 수 있게 웹 서버와 소켓을 만들어 통신함. (톰캣이 대표적인 서블릿 컨테이너!)
- 서블릿의 생명주기를 관리함
- 요청이 서블릿 컨테이너로 들어옴 -> ServletRequest, ServletResponse 객체 생성 -> 설정 파일을 참고해서 매핑할 서블릿 확인 -> 서블릿 인스턴스 존재 유무 확인 후, 없으면 init()으로 생성 -> 서블릿 컨테이너에 스레드 생성 -> HttpServletRequest, HttpServletResponse를 인자로 서비스 실행
- 요청이 여러개 들어오면? 멀티스레드로 요청 처리

### 서블릿 컨텍스트

- 서블릿 컨테이너에 서블릿을 등록하면, 해당 서블릿이 갖는 하나의 작은 컨테이너 역할을 하는 객체
- 스프링 IoC 컨테이너인 ApplicationContext를 부모 컨텍스트로 사용

### Bean이란

스프링 빈이란, 스프링 IoC 컨테이너가 관리하는 객체입니다.
스프링부트의 경우, @Configuration이 달려있는 클래스에 @Bean 애너테이션으로 직접 선언하여 등록하거나, 클래스에 @ComponentScan(리포지토리, 서비스 포함)이 달려있는 클래스들을 스캔하여 빈으로 등록합니다.

### Bean 스코프

빈 스코프란? 빈이 존재할 수 있는 범위를 말합니다.

- Singleton : 해당 빈에 IoC 컨테이너에서 단 하나의 객체로만 존재 (스프링 컨테이너와 같은 라이프 사이클)
- Prototype : 해당 빈에 대해 다수의 객체 존재 가능 (스프링 컨테이너는 생성과 의존관계 주입만 해주고 끝)
- Request : 해당 빈에 대해 하나의 HTTP Request 라이프사이클에서 단 하나의 객체로만 존재(웹 요청이 들어오고 나갈때까지 유지됨)
- Session : 해당 빈에 대해 하나의 Session 라이프사이클에서 단 하나의 객체로만 존재(세션이 생성되고 종료될 때 까지 유지됨)
- Application : 서블릿 컨텍스트와 같은 범위로 유지됨

### ApplicationContext

빈 팩토리를 상속받아 확장한 IoC 컨테이너 입니다. @Configuration과 같은 애너테이션이 IoC 설정 정보인데, 이를 참조해서 빈을 등록합니다.

- 장점
    - 클라이언트는 @Configuration이 붙은 구체적인 팩토리 클래스를 알 필요가 없음
    - 애플리케이션 컨텍스트는 종합 IoC서비스를 제공해줌
    - 애플리케이션 컨텍스트를 통해 다양한 빈 검색 방법을 제공함

### BeanFactory VS ApplicationContext

- 빈 팩토리
    - Bean을 제공하고 관리하는 기본적인 IoC 컨테이너 인터페이스. getBean()이 호출될 때 빈을 인스턴스화
- ApplicationContext
    - 빈 팩토리의 확장된 버전. 이는 직접 빈을 생성하고 관리하기보다, @Configuration과 같은 IoC 설정 정보를 이용하여 빈을 생성하고, DI를 해줌. 애플리케이션이 시작될 때 빈을 인스턴스화 함.
    - 추가적으로, 애플리케이션에 대한 모든 정보와 메타 데이터도 가지고 있다.

### 스프링 컨테이너의 생명 주기

ApplicationContext를 이용한 스프링 컨테이너의 경우

> 컨테이너 초기화(생성) -> 빈 설정 -> 빈 사용 -> 컨테이너 종료
> 

참고로, 빈의 생명주기는 스프링 컨테이너의 생명 주기와 동일합니다.

> 스프링 컨테이너 초기화 : 빈 객체 생성 및 DI스프링 컨테이너 종료 : 빈 객체 소멸
> 

### 싱글톤

- 싱글톤은 객체를 공유하게 함으로써, 무분별한 객체 생성을 막는 패턴입니다.
- CGLIB 라이브러리가 프록시 객체를 생성하여 이를 빈으로 등록함으로써, 싱글톤이 되도록 보장해줌.
- 주의
    - 무상태 설계
    - 가급적이면 읽기만
    - 필드 대신, 지역 변수, 파라미터, ThreadLocal 등을 사용

### AOP

AOP란, 관점 지향 프로그래밍으로, 로직을 기준으로 중복된 코드들(공통 관심 사항)을 뽑아서 관점적으로 모듈화하여 재사용하는 것입니다.

제가 이부분은 자세히는 알지 못하지만, Proxy 패턴이 AOP에 해당한다고 알고있습니다. 제가 알고있는 Proxy 패턴을 이용하는 것 중 대표적인 케이스는 @Transactional 애노테이션입니다.

### Spring의 이점

- 서비스에서 비즈니스 로직을 분리하기 위해 AOP를 지원합니다.
- IoC 컨테이너가 있기 때문에, 스프링 빈의 라이프 사이클과 구성을 대신 관리해줌
- MVC 프레임워크를 통해 웹 앱과 RESTful API를 설계할 수 있음.

### @Controller, @Service, @Repository 차이

- @Controller는 컨트롤러의 역할임을 알리는 애너테이션입니다.
    - 컨트롤러는 요청을 받아 처리하고 응답합니다.
- @Service는 비즈니스 로직을 처리해주는 애너테이션입니다.
    - 컨트롤러에서 요청을 받아서 보통 서비스 단에 넘깁니다. 이 때, 변화에 유연하게 대처하기 위해, 그리고 모든 정보를 노출하지 않기 위해 엔티티를 직접 사용하면 안되고, 데이터 전달 역할로써 DTO를 사용해야 합니다.
- @Repository는 리포지토리임을 알리는 애너테이션입니다.
    - DB관리와 엔티티의 CRUD를 담당합니다.

### DAO, DTO, VO

- DAO(DataAccessObject) : DB의 data에 접근하기 위한 객체
- DTO(DataTransferObject) : 계층 간 데이터 교환을 위한 객체
- VO(ValueObject) : 값을 나타내기 위한 객체 (불변, readOnly)

### Spring VS SpringBoot

스프링부트는 스프링을 보다 편리하게 사용할 수 있게 해주는 프레임워크입니다.

스프링부트는 스프링 프레임워크를 사용하기 위해, 설정 부분을 대부분 자동화 했으며, 편리하게 API나 하위 프레임워크를 추가할 수 있게 해줍니다.

### Spring MVC

스프링 프레임워크에서 제공하는 웹 모듈이며, MVC란 Model, View, Controller의 약자입니다.

Model은 데이터 전송을 담당합니다.
View는 화면 출력을 담당합니다.
Controller는 요청을 받아 모델에 데이터를 담고, 뷰로 전달 시켜주는 역할을 담당합니다.

### MVC pattern의 흐름

요청이 들어오면, 이를 프론트 컨트롤러인 디스패처 서블릿에서 받습니다. 그럼 요청에 해당하는 HandlerMapping을 통해 핸들러 정보를 찾습니다.

그 후, 핸들러를 처리할 수 있는 HandlerAdapter를 찾습니다. 핸들러 어댑터는 요청에 맞는 Controller에 요청을 전송해줍니다.

컨트롤러가 요청을 처리하여, ModelAndView를 반환합니다. 그럼 ViewResolver가 호출되고, 그에 맞는 html파일을 찾아 응답을 보내주고, 화면이 렌더링 됩니다.

만약, RESTful API통신일 경우에는, 응답이 View가 아닌, HttpMessageConverter를 통해 Http 바디에 직접 String, 혹은 JSON 형태로 반환해줍니다.

### MVC1 vs MVC2

- mvc1 : 요청을 JSP 페이지가 받아서 처리 - 컨트롤러 + 뷰
- mvc2 : 클라이언트 요청을 서블릿이 받음.

### 디스패처 서블릿

- 프론트 컨트롤러 역할을 합니다. 요청이 들어오면 요청에 대해 핸들러 매핑을 통해 핸들러를 찾아주고, 핸들러 정보에 맞는 핸들러 어댑터를 찾아 핸들러 정보를 전달해주는 역할을 합니다.
- 디스패처 서블릿 덕분에 공통 작업을 코드 중복 없이 처리할 수 있게 되었습니다.

### 서블릿

- 서블릿은 자바를 기반으로 하는, 동적 웹페이지를 만들어줄 수 있는 프로그래밍 기술입니다.
- 서블릿을 통해, 요청과 응답의 흐름을 메서드 호출만으로 다룰 수 있게 해줍니다.
- 서블릿은 서블릿 컨테이너를 통해 생명 주기가 관리되고, 통신을 지원합니다.

### 서블릿 컨텍스트

- 서블릿 컨테이너와 통신하기 위해 사용되는 메소드를 지원하는 인터페이스

### 테스트 코드

- 개발 초기 단계에 문제를 발견할 수 있음
- 코드를 리팩토링해도 기존 기능이 잘 작동하는지 확인할 수 있음
- 기능에 대한 불확실성이 감소함
- JUnit5, Mock 등 라이브러리 이용

### 스프링 시큐리티

스프링 시큐리티는 인증과 인가를 위한 스프링 하위 프레임워크입니다.
동작 방식은 다음과 같습니다.

인증 관련 요청이 들어오면 -> 시큐리티 필터가 요청을 낚아챕니다. -> 필터는 요청에 대한 인증을 AuthenticationManager에게 위임을 합니다. -> 그리고, AuthenticationManager는 내부에 AuthenticationProvider라는 인증 로직을 수행하는 객체를 가지고있습니다. 대표적으로, UserDetails와 PasswordEncoder가 있습니다. -> 요청에 해당하는 인증 로직을 수행하게 되면, 인증객체가 반환됩니다. -> 반환된 인증 객체는 SecurityContext에 저장되고 관리됩니다.

### 필터 vs 인터셉터

필터와 인터셉터의 큰 차이는 작동되는 위치입니다.
필터는 서블릿 이전에 위치되어 수행되고, 인터셉터는 서블릿 이후에 위치되어 컨트롤러 호출 전/후에 수행됩니다.

다른 차이점은, 필터는 자바 표준 스펙이고 인터셉터는 스프링이 제공하는 기술이라는 점입니다.

### 스프링 애너테이션

특별한 의미, 기능을 수행하도록 하는 기술. 즉, 프로그램에게 추가적인 정보를 제공해주는 메타데이터임

### Controller VS RestController

컨트롤러는 요청을 처리한 후에 View의 논리 이름, 즉 ModelAndView를 반환합니다. 이를 토대로 View의 위치를 확인하고, html파일을 찾아 응답해줍니다.

레스트컨트롤러는 Http 바디에 직접 데이터를 내려줍니다. 이 때, Controller와는 다르게, HttpMessageConverter가 작동한다는 차이점이 있습니다. 응답 데이터는 단순 String 형태거나, JSON 데이터 형태가 될 수 있습니다.

### JPA

인터페이스로서, 자바 표준 ORM(Object-relational mapping)입니다. 객체와 DB간의 관계를 편리하게 이어주는 역할을 하며, 대표적인 구현체는 Hibernate가 있습니다. 스프링부트를 이용하면 Hibernate를 직접적으로 이용하진 않으며, Spring Data JPA를 통해 이용하게 됩니다. 이는 구현체, 혹은 저장소 교체의 용이성을 위한 것입니다.

### 영속성 컨텍스트

엔티티를 영구 저장하는 환경이라는 뜻입니다. 앱과 DB사이에서 엔티티를 보관하는 가상의 환경입니다. 이는 엔티티 매니저를 통해서 접근할 수 있습니다.

영속성 컨텍스트의 생명주기는 트랜잭션과 동일하기 때문에, 트랜잭션이 종료되면 영속성 컨텍스트도 종료됩니다.

또한, 영속성 컨텍스트와 엔티티의 생명 주기는 서로 밀접한 관련이 있습니다. 엔티티 생명 주기는 다음과 같습니다.

- 비영속 : 영속성 컨텍스트와 관련없는 새로운 상태
- 영속 : 영속성 컨텍스트에 의해 관리되는 상태
- 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제 : 삭제된 상태

### 영속성 컨텍스트의 장점

- 1차 캐시
    - persist 하면 1차 캐시에 저장되어, 트랜잭션 내에서 재 조회시 쿼리 없이 조회가 가능하다. 또한, DB에서 조회해와도 1차 캐시에 저장된다.
- 동일성 보장
    - 1차 캐시를 지원함으로써, 반복된 읽기등급의 트랜잭션 격리 수준을 DB가 아닌 애플리케이션 차원에서 제공한다.
- 트랜잭션을 지원하는 쓰기 지연
    - persist를 해도, DB에 쿼리를 날리지 않고, 쓰기 지연 저장소에 저장된다. 트랜잭션이 커밋되는 순간 DB에 쿼리를 날린다.
- 변경 감지
    - DB에서 조회를 하면, 엔티티에 대한 정보가 스냅샷 저장소에 저장된다. 그리고, 엔티티의 정보가 변경되면, 변경을 감지해서 쓰기지연 저장소에 업데이트 쿼리를 저장해둔다. 그 후, 트랜잭션이 커밋되면 업데이트 쿼리가 날아간다.
- 지연 로딩
    - 일대다의 관계가 있을 때, 1에 해당하는 엔티티만 확인하고 싶을 경우, N에 해당하는 엔티티는 굳이 조회해오지 않아도 된다. 이럴 때, 지연로딩으로 설정하면, N에 해당하는 객체는 가짜 프록시 객체를 가져온다. 추후, 실제 엔티티 조회가 필요할 때는 실제 엔티티를 가져온다.

### 플러시

- 영속성 컨텍스트의 변경 내용을 DB에 반영 (쓰기지연 저장소에 있던 쿼리 DB에 날림)
- 영속성 컨텍스트를 비우지 않음
- 영속성 컨텍스트의 변경 내용을 DB에 동기화
- Tx 커밋 시 자동으로 호출

### CascadeType, orphanRemoval

- CascadeType은 서로 관계가 맺어진 엔티티의 생명 주기를 맞춰주는 설정 정보입니다.
    - ALL : 엔티티의 모든 연산 과정에 대해 서로 맞춰줌
    - PERSIST : 엔티티를 persist 할 때만 함께 persist
    - MERGE : 엔티티를 merge 할 때만 함께 merge
    - REMOVE : 엔티티를 제거할 때만 함께 제거
    - REFRESH : 엔티티를 리프레시 할 때만 함께 리프레시..?
    - DETACH : 엔티티를 detach할 때 함께 detach
- OrphanRemoval은 다대일 양방향 매핑으로 이루어진 두 개의 엔티티가 있을 때, 부모 엔티티의 List에서 자식 엔티티를 remove하면, 고아 객체로 판단되고 삭제가 되는 것입니다.
- CascadeType = ALL로 설정하고, OrphanRemoval = true로 설정하면, 부모 객체에서 자식 객체의 생명 주기를 관리할 수 있습니다.

### N+1 문제와 그 해결법

N+1문제는 하나의 객체를 조회했는데, N개의 쿼리가 더 나가는 현상을 말합니다. 이는 관계 설정이 된 엔티티를 지연로딩으로 조회해올 때 발생하는 문제입니다.

이는 fetchJoin을 이용하면 해결된다고 알려져있습니다.

하지만, 제가 마주한 경우에는 fetchJoin으로 해결할수 없던 경우였습니다. 저의 경우, 3개의 엔티티가 다대일, 다대일 매핑을 이루고 있던 상태였습니다.

제가 fetch join을 사용하면 해결 되겠지?라고 생각했고, join문 두 개에 모두 페치 조인을 수행하도록 쿼리를 구성하는 만행을 저지릅니다. 그러고 나서, 당연히 됐겠지.. 하고 로직을 테스트 해봤는데요, 예외가 바로 터졌습니다.

그래서, 저는 생각했습니다. 페치 조인을 사용하지 못하면, 어떻게 N+1문제를 해결할수 있을까?라고 생각했고, 도저히 혼자서는 해결 방법이 떠오르질 않아서, 검색을 시작했습니다.

검색을 해보니, `default_batch_fetch_size`라는 옵션을 알게되었습니다. 이 옵션에다가 설정값을 지정해주면, 최대 설정값 만큼의 엔티티를 in절을 이용해서 한번에 조회해오는 기능입니다. 그래서 이를 이용해서, N+1을 해결하고자 했으며, 적용한 결과 N+1문제가 해결되었음을 확인했습니다.

그런데 더 큰 문제는 다른 문제였는데, 경고 메세지가 하나 있는 것을 발견했습니다. "지금 너는 데이터를 메모리에서 조회해오고 있어.. 이거 위험해.."라는 메세지였습니다. 메모리 문제라면, OutOfMemory가 발생해 장애가 날 것이기 때문에, 반드시 해결해야 했습니다.

이게 왜 발생한걸까? 를 생각했습니다.

혹시, 쿼리가 잘못되었나? 하고 쿼리를 보는데, 제가 페이징을 하기위해 작성해둔 쿼리에 limit과 offset이 빠진 것을 확인했습니다.

그래서, 이를 해결하기 위해 join과 paging이라는 키워드로 검색을 하여 원인을 알아냈습니다. ManyToOne 관계에서, One에 해당하는 엔티티를 기준으로 조인을 하면, 데이터 개수가 변할 수 밖에 없습니다. 이럴 경우, 페이징이 적용이 되지 않도록 JPA에서 막아놨다고 합니다. 그래서 페이징 쿼리가 나가지 않는 것이었습니다.

대신, 쿼리 결과를 전부 메모리 내에 적재한 후 페이징을 애플리케이션 레벨에서 수행해버리게 된다고 하며, 이 때문에 발생한 경고 메시지였던 것입니다.

이를 해결하고자, 쿼리를 재구성을 해야겠다고 생각했습니다.

방법이 뭘까?를 계속 고민했는데, 제가 생각한 최선의 결과는 다음과 같습니다.

세 엔티티를 InnerJoin하고, 키워드 조건과 만족하는 Post의 Id를 찾는 쿼리를 날립니다. 그 결과를 List형태로 받아옵니다.

그리고 페이징 쿼리를 날릴 때, in절을 이용해서 postId에 해당하는 Post에 대해서만 페이징을 수행하도록 쿼리를 구성했습니다.

이렇게해서 1차적으로는 해결이 되었습니다만, 제가 DB쪽이 조금 부족하다보니까, 제 해결 방법에 대한 확신이 없습니다. 많은 테스트를 통해 제대로 작동을 함을 혼자서 검증은 했지만, 제대로 해결이 된건지는 잘 모르겠습니다. 그래서, 이 부분은 데이터를 많이늘려서 시도해보거나, 더 좋은 방법이 있는지 지속적으로 검토하는 등의 후처리가 필요할 것 같습니다.

### @Transactional과 트랜잭션 전파
