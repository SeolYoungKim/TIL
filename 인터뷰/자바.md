### 객체 지향이란

실생활에 사용되는 모든 것이 객체입니다. 객체 지향 프로그래밍이란, 프로그래밍 구현에 필요한 객체를 파악하고, 정의하여 객체들간의 상호 작용을 통해 프로그램을 만드는 것을 말합니다.

### 객체지향 5대 원칙

**단일 책임 원칙** : Single Responsibility Principle

- 한 클래스는 하나의 책임만 가진다.
- 변경이 있을 때 파급효과가 적다면 단일 책임 원칙을 잘 따른 것이다.

**개방-폐쇄 원칙 : Open-Closed Principle**

- 소프트웨어는 확장에는 열려있으나 변경에는 닫혀있어야 한다
- 다형성을 활용한다 (인터페이스)

**리스코프 치환 원칙 : Liskov Substitution Principle**

- 부모 객체를 호출하는 동작에서, 자식 객체가 부모 객체를 완전히 대체할 수 있다는 원칙
- 인터페이스를 구현한 구현체를 믿고 사용하기 위해, 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다.

**인터페이스 분리 원칙 : Interface Segregaion Principle**

- 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스 하나보다 낫다
- 인터페이스를 분리하면 다른 하나의 인터페이스가 변해도 다른 인터페이스에 영향을 주지 않음
- 인터페이스가 명확해지며, 대체 가능성이 높아짐

**의존관계 역전 원칙 : Dependency Inversion Principle**

- 프로그래머는 추상화에 의존해야 한다. (구체화 X)
- 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
- 의존성 주입은 해당 원칙을 따르는 방법 중 하나
- 유연하게 구현체를 변경하기 위함

### 객체지향 프로그래밍의 특징과 장점

- 객체지향 프로그래밍 특징 : 추상화, 캡슐화, 상속, 다형성
- 코드를 재사용성이 높고, 유지보수가 쉽게 만들어줌
- 신뢰성 높은 프로그래밍
- 추상화 : 공통된 속성이나 기능을 찾아내서 공통된 조상을 만듦 (추상 클래스, 인터페이스)
- 캡슐화 : 객체의 속성과 행위를 하나로 묶고, 구현 내용을 외부로부터 감춤(클래스로 하나로 묶은 후, 내부에 접근제어자를 두어 외부 접근 방지)
- 상속 : 부모 클래스의 특성을 자식 클래스가 상속받음
- 다형성 : 여러가지 형태를 가질 수 있는 능력 (한 타입 참조변수로 여러 타입 객체 참조 가능)

### 객체 VS 클래스

클래스는 객체를 만드는 설계도라고 할 수 있으며, 이 클래스를 참조하여 객체(인스턴스)를 생성함

### JVM 메모리 구조

시스템으로부터 프로그램 수행에 필요한 메모리를 할당받고, 5개의 영역으로 나누어서 관리

**Runtime Data Areas**

- JVM이 OS 위에서 실행되면서 할당받는 메모리 영역
- 총 5개의 영역으로 나눠서 관리
    - **PC 레지스터** : 스레드가 어떤 명령어로 실행되어야 할지 기록 (현재 수행 중인 JVM 명령어 주소를 가짐). 현재 작업중인 내용을 CPU에게 연산으로 제공. -> 이를 위한 버퍼 공간으로 PC 레지스터를 제공
    - **JVM 스택** : 메서드에 대한 정보가 저장됨(지역변수, 매개변수, 메서드, 임시데이터 등). 기본 자료형을 생성할 때 저장. 임시적으로 사용되는 변수나 정보들이 저장 됨.
    - **네이티브 메서드 스택** : 실제 실행 가능한 기계어로 작성된 프로그램을 실행시킴
    - **힙 영역** : 런타임에 동적으로 할당되는 데이터가 저장되는 영역. (객체나 배열 생성). 메서드 영역과 함께 모든 쓰레드가 공유하는 영역임.
        - JVM이 관리하는 프로그램 상에서 데이터를 저장하기 위해 런타임 시 동적으로 할당하여 사용함
        - new 연산자로 생성되는 클래스, 인스턴스 변수, 배열 타입 등 referenceType이 저장되는 곳
        - 힙에 할당된 데이터들은 GC의 대상이 된다.
    - **메서드 영역** : JVM이 시작될 때 생성됨. 모든 쓰레드가 공유. 필드, 메서드, 타입 정보를 갖고 있음. 즉, **정적 필드와 클래스 구조**만을 갖고 있음

### 컴파일 방법

1. 자바 소스 코드 작성(`.java`)
2. **Java Compiler**가 `.java`를 컴파일 함
3. 컴파일 결과, 자바 바이트 코드(`.class`)파일이 생성됨
    - 이 파일은 아직 컴퓨터가 읽을 수 없다.
    - 이 파일은 자바 가상머신이 이해할 수 있다.
    - 바이트 코드의 각 명령어는 1 바이트 크기의 [Opcode](https://ko.wikipedia.org/wiki/%EB%AA%85%EB%A0%B9_%EC%BD%94%EB%93%9C)와 추가 피연산자로 이루어져 있다.
4. 컴파일된 바이트 코드(`.class`)를 JVM의 Class Loader에게 전달
5. **Class Loader**는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩하고 링크함
→ 클래스들을 런 타임 데이터 영역(Runtime Data Area), 즉 JVM의 메모리에 올림
    
    ☝ Class Loader는 다음과 같이 동작합니다!
    
    1. 클래스 파일을 JVM 메모리에 **로드**
    2. 자바 언어 명세(Java Language Specification) 혹은 JVM 명세에 명시된 대로 구성되었는지 **검증**
    3. 클래스가 필요로 하는 메모리를 **준비**하여 할당(필드, 메서드, 인터페이스 …)
    4. 클래스의 상수 pool 안의 모든 symbolic reference를 **분석**하여 direct reference로 변경
    5. 클래스 변수(static field)들을 적절한 값으로 **초기화**
6. **실행 엔진(Execution Engine)** 은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행함 (바이트 코드 → 네이티브 코드)
    
    ☝ 이 때, 실행 엔진은 두 가지 방식을 사용할 수 있다.
    
    - Interpreter
        - 바이트 코드 명령어를 하나씩 읽어 해석하고 실행함
        - 하나 하나의 실행은 빠르지만, 전체적인 실행 속도가 느림
    - JIT compiler(Just-In-Time)
        - 인터프리터의 단점을 보완하기 위해 도입
        - 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경
        - 이후, 해당 메서드를 더이상 인터프리팅 하지 않으며, 바이너리 코드로 직접 실행함
        - 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에, 전체적인 실행 속도는 인터프리터 방식보다 빠름

### 클래스 변수(static) vs 인스턴스 변수

- 클래스 멤버는 클래스가 메모리에 올라갈 때 생성되며, 모든 인스턴스가 공유함.
- 인스턴스 멤버는 인스턴스가 생성될 때 생성되며, 각 인스턴스가 독립적인 변수를 가짐.

### 오버로딩 vs 오버라이딩

- 오버로딩 : 한 클래스 내에 매개변수의 개수나 타입이 다른, 같은 이름의 메서드를 여러개 정의하는 것
- 오버라이딩 : 부모 클래스(인스턴스)로부터 상속받은 메소드를 재정의

### 접근 제어자

- 클래스, 메서드, 변수 등을 외부에서 접근하는 것을 방지
- public - protected - default - private

### 인터페이스 vs 추상클래스

- 추상클래스 : 추상 메서드를 갖고있는 "일반 클래스" + 생성자, 인스턴스 변수.. 등을 갖고 있음. 다중상속 불가.
- 인터페이스 : 추상 메서드의 집합이다. 자바 8 들어와서는 static, default 제어자를 가질 수 있으나, 생성자, 인스턴스 변수, 인스턴스 메서드를 가질 수 없음. 다중상속 가능.

### static 이란?

제어자로써, "공통적인"이라는 의미가 있음. 모든 객체가 공유할 수 있게 되지만, GC의 관리 영역 밖에 존재하므로 주의.

### primitive type VS reference type

- primitive : 기본 자료형 타입. 8개의 타입이 있고, 실제 값을 저장하는 **스택 메모리**에 저장 됨
- reference : 참조형 타입. null 포함 가능. new 연산자를 통해 생성되므로, 주소값을 저장하는 공간인 heap에 저장됨

### 업캐스팅 vs 다운캐스팅

- 서로 상속 관계에 있는 클래스에서 할 수 있음
- 업 캐스팅 : 자손 -> 조상 클래스 타입의 참조변수로 형변환
- 다운 캐스팅 : 조상 -> 자손 클래스 타입의 참조변수로 형변환

### Error vs Exception

- Error : 프로그램 코드로 수습 불가능한 심각한 오류
- Exception : 프로그램 코드로 수습이 가능한 다소 미약한 오류
    - 체크 예외 : 컴파일러가 체크를 해주는 예외. 반드시 처리를 해줘야 함. 런타임 예외를 제외한 Exception 클래스의 하위 클래스들이 여기에 속함.
    - 언체크 예외 : 컴파일러가 체크해주지 않는 예외 (런타임예외). 처리를 해주지 않아도 됨

### 얕은 복사 vs 깊은 복사

- 얕은 복사 : 새로운 객체를 만들고, 원본의 값을 복제하는 게 아닌, 원본을 참조하는 형식. 불변 요소는 가져오지만, 가변 요소는 같은 주소를 가리킴
- 깊은 복사 : 새로운 객체를 만들고, 내용을 새로 생성해서 복사함. 복사된 객체는 원본 객체와 무관.

### String vs StringBuilder vs StringBuffer

- String : 불변 객체. heap안의 상수 풀에 저장 됨.
- StringBuilder : heap에 저장되고 변경이 가능. 동기화를 지원하지 않아 쓰레드에 안전하지 않음.
- StringBuffer : heap에 저장되고 변경이 가능. 동기화를 지원하여 쓰레드에 안전함.

### 제네릭

- 다양한 타입의 객체를 다룰 수 있도록 도와주는 타입 매개 변수
- 제네릭 타입을 사용하면, 타입 체크 및 형변환을 생략할 수 있고, 잘못된 타입 사용 시 컴파일에러가 나게 한다.

### 애노테이션

- 일종의 메타 데이터.
- 프로그램을 위한 정보를 미리 약속된 형식으로 포함시킨 것
- 역할
    - 컴파일러에게 정보 제공
    - 소프트웨어 개발 툴이 빌드 혹은 배치 시 코드를 자동으로 생성할 수 있도록 정보 제공
    - 실행 시 특정 기능을 실행하도록 정보 제공

### 래퍼 클래스

- 기본형 변수를 객체 형태로 사용할 수 있게 만든 클래스

### CallByValue vs CallByReference

- call by value : 값에 의한 호출. 함수 호출 시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달함. 복사된 인자는 지역변수의 특성을 가짐
- call by reference : 참조에 의한 호출. 함수 호출 시, 인자로 전달되는 변수의 레퍼런스를 전달. 그로 인해 함수 내부에서 인자의 값이 바뀔 경우, 인자로 전달되었던 변수의 값도 함께 변경 됨

> 자바는 Call By Value로 이뤄져 있음.
참조 자료형을 매개 변수로 넘길 때, 참조 매개변수에 전달했던 변수의 주소값을 복사하여 값으로 가짐.
> 
> 
> 그로 인해, 함수 내부에서 해당 변수에 새로운 객체를 만든 후, 주소 값을 저장한다 하더라도, 원본 변수의 주소 값이 변하지 않기 때문에, 원본 변수가 가리키는 객체가 변하지 않음
> 

### Thread start vs run

- 콜스택 : 실질적인 명령어를 담고있는 메모리. 멀티 쓰레드는 여러 개의 콜스택을 번갈아가며 처리한다.
- run() : 쓰레드 내부의 run()메서드를 호출하는 것 뿐.
    - main 메서드에서 쓰레드를 생성한 후, `run()`을 호출하면 main 쓰레드 내의 콜 스택에서 실행 됨.
- start() : 쓰레드를 위한 콜 스택을 새로 생성한 후 그 위에서 실행 됨.

### 병행 vs 병렬

- 병행 : 여러 일을 동시에 수행하는 것 처럼 매우 짧은 시간에 번갈아가며 수행
- 병렬 : 멀티 코어 환경에서 실제로 여러 일을 동시에 수행 (core는 한번에 한가지 일만 처리)

### 쓰레드 그룹

- 서로 관련된 쓰레드를 그룹으로 다루기 위한 것
- 모든 쓰레드는 반드시 쓰레드 그룹에 포함되어 있음

### 쓰레드 vs 데몬 쓰레드

- 일반 쓰레드 : 기본적인 쓰레드를 의미 (실행 단위)
- 데몬 쓰레드 : 일반 쓰레드를 도울 목적으로 만들어진 쓰레드. 특정 조건이 되면 작업을 수행하고 대기. 일반 쓰레드 종료 시 종료.

### 쓰레드의 상태

NEW, RUNNABLE, BLOCKED, WAITING, TERMINATED

### Map, Set, List 설명하기

- Map은 키-값 쌍으로 이루어진 자료구조입니다. 키는 중복될 수 없고, 순서를 보장 하지 않습니다.
    - HashMap - "key:value" null 허용. 동기화 보장 X. 검색 성능 굿
    - HashTable - "key:value" null 비허용.
    - LinkedHashMap - 입력된 순서 보장
    - TreeMap - 이진 탐색 트리를 기반으로 "key:value" 저장. 저장 시 정렬을 하기 때문에 시간이 오래 걸림
- Set은 순서를 보장하지 않고, 중복을 허용하지 않습니다.
    - HashSet - 인스턴스 해시값을 기준으로 저장. 순서 보장 X. null 허용. 삽입 및 삭제가 빠름
    - LinkedHashSet - 입력된 순서를 보장
    - TreeSet - 이진 탐색 트리를 기반으로 함. 삽입 및 삭제는 느리나, 정렬이 빠름. 데이터가 오름차순으로 정렬 됨.
- List는 순서를 보장하고, 중복을 허용합니다.
    - LinkedList - 양방향 포인터 구조. 삽입 및 삭제가 빠르나 검색이 느림
    - ArrayList - 단방향 포인터 구조. 데이터 순차 접근 가능. 삽입 및 삭제가 느리나 검색이 빠름

### GC

GC란, JVM이 주기적으로 heap영역에 할당된 객체 중, 사용하지 않는 객체들을 제거해주는 작업을 말합니다.

GC의 동작 방식은 다음과 같습니다.

새로운 객체가 생성되면,  heap의 Eden이라는 영역의 메모리에 할당됩니다. 그리고, Eden이 꽉차면, 이 때 Minor GC가 발동되는데, 사용 중인 객체는 사용 중이라고 "reachable" 태그를 해줍니다. 사용되지 않는 객체는 "unreachable"태그를 해줍니다.

그럼, "reachable" 태그된 객체들은 survivor 영역으로 들어가게 되고, age값이 1증가합니다. 반면에, "unreachable" 태그 객체들은 메모리가 해제되게 됩니다.

두번째로, Eden영역이 새로운 객체들로 다시 꽉차게 된다면, MinorGC가 발동되고, 이 때는 Eden영역과 Survivor 영역 모두 체크하게 됩니다.

똑같이 "reachable" 태그된 객체들은 age값을 1증가시키고, "unreachable" 태그 객체들은 메모리가 해제됩니다.

이를 계속적으로 반복하다가, age값이 임계값에 다다르게 되면 해당 객체는 old 영역으로 이동하게 됩니다.

old영역이 꽉 차게 될 경우에는, Major GC가 발동되는데, 이는 Full GC라고도 합니다. 해당 방식은 Minor GC에 비해 매우 느립니다.

그리고 Full GC가 발동되면, 앱을 실행하던 모든 스레드가 멈추고 GC에만 투입되는 Stop The World 문제가 발생합니다.
