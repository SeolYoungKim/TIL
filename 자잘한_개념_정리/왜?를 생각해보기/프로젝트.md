# 해당 프로젝트를 하게된 이유

제가 혼자서 하는 것보다는 협업을 좀 더 좋아합니다.  협업을 함으로써, 함께 성장한다는 것을 느껴보고 싶었고, 디자인, 프론트엔드 단의 다른 분야 분들과 협업을 해보면서, 의사소통 능력도 키워보고 싶었습니다.

그래서 사이드 프로젝트를 하기로 마음을 먹고, 사이트 이곳 저곳을 돌아다니기 시작했습니다.

그런데, 저같은 초보가 여길 과연 지원해도 될까? 내가 민폐가 되는것은 아닐까? 하는 막연한 두려움이 있었고, 이에 대한 보조 지표가 있으면 좋겠다고 생각을 했습니다.

이런 상태에서 제가 어딘가에 참여를 요청하기가 두려웠기에, 저와 비슷한 레벨의 사람들을 제가 모으기 시작했고, UI/UX 디자이너, 프론트엔드 두분을 모집해서 총 3인의 팀을 꾸리게 되었습니다.

그후, 서로 프로젝트에 대한 의견을 나누고, 두 분 모두 제가 제시한 현재 사이드 프로젝트 사이트들의 문제점에 대해 공감을 해주셨고, "좀 더 구체적인 사이드프로젝트 웹 앱 Siders"라는 프로젝트를 진행하게 되었습니다.


# 이유 분석

## 패키지 구조 설계 이유

각각의 역할에 집중해서 설계를 했습니다.

크게 **인증, 설정, 도메인, 리포지토리, 예외, 서비스, 웹** 으로 구성하였고, 특히 웹 계층은 **컨트롤러, 요청, 응답** 으로 세분화 하여 관리하였습니다.  

요청, 응답 패키지에서는 DTO들을 관리하였고, 각 엔티티에 따라 패키지를 구성해서 엔티티 별 DTO를 관리하도록 세분화했습니다. 또한, 요청 DTO의 경우 저장 목적인지 수정 목적인지, 혹은 서치 목적인지에 따라 또 패키지를 나누었습니다.


## 도메인을 기술 스택, 모집 분야, 글, 회원으로 나누었는데 이유는?

저희가 만들고자 하는 웹 앱은 모집 분야에 대해 "요구 능력치에 대한 보조 지표"를 제시할 수 있는 앱입니다. 이를 어떻게 구현할까 고민을 하다가, 최종적으로 4가지의 엔티티가 필요하다고 판단했습니다.

그러고 나서, 4 개의 엔티티에 대한 관계 매핑을 고민했습니다.

저는 게시글 엔티티에 모집 분야라는 엔티티를 여러개 추가할 수 있게 구성하고 싶었고, 모집 분야는 분야 별 모집 인원을 설정하고, 분야에 대한 숙련도를 "low, mid, high" 셋 중에서 고를 수 있게 구성하고 싶었습니다.

또한, 게시글을 조회할 때 모집 분야에 대한 리스트가 보여져야 하기 때문에, 모집 분야와 게시글은 다대일 양방향 매핑으로 연관관계를 구성했고, 부모 엔티티인 게시글 엔티티에서 모집 분야의 생명주기를 관리할 수 있도록, `cascade=ALL, orphanRemoval=true`로 걸었습니다.

그 다음, 모집 분야 별로 기술 스택을 선택할 수 있도록 구성하고자 했습니다. 각 모집 분야마다 요구되는 기술 스택이 여러개일 것입니다.  또한, 게시글에서 모집 분야에 할당된 기술 스택들도 노출이 되어야 했습니다. 그래서, 기술 스택과 모집 분야도 다대일 양방향 매핑으로 구성했습니다.

이 때, 기술 스택의 엔티티 생명 주기도 관리를 해줘야 했습니다. 이미 게시글에서 모집분야를 지우면, 기술스택에 모집 분야의 FK가 남아있는 상태이기 때문에 예외가 발생했습니다. 그래서, 기술 스택의 엔티티 생명 주기는 모집 분야에서 관리할 수 있도록 `cascade=ALL, orphanRemoval=true`로 걸었습니다.

마지막으로, 회원과 게시글의 관계입니다. 게시글은 반드시 회원만 작성할 수 있도록 인증 및 인가 로직을 구성하고자 했습니다. 또한, 회원이 개인 페이지를 들어갔을 때, 본인이 작성한 게시글들을 목록화 해서 보여주고자 했습니다.

따라서, 게시글과 회원의 관계도 다대일 양방향 매핑으로 구성하였으며, 회원이 탈퇴할 경우, 게시글이 전부 삭제되어야 하기 때문에 게시글 엔티티의 생명주기를 회원 엔티티에서 관리하고자 `cascade=ALL, orphanRemoval=true`로 걸었습니다.


## 기능 구성 - 인증/인가

글 작성, 수정, 삭제 및 개인정보 조회 등은 인증된 유저만 가능하도록 구성하고 싶었습니다. 이에 따라, 인증/인가를 무엇을 이용할지 많은 고민을 했는데요.

서버사이드렌더링으로 게시판을 구현할때는 Spring Security와 OAuth2 프레임워크가 제공하는 기능만을 이용해서 편하게 인증/인가를 구현했었습니다.

그래서 프론트엔드분과 작업할때도 크게 다르지 않을거라고 판단해서 이를 이용하기로 했구요, 다만 이제 프론트엔드 측에서 OAuth2 인증 서버까지, 인증이 요구되는 통신을 백엔드를 거쳐가며 하기에는 너무 비효율적이라고 생각했습니다.

그래서 Spring Security + OAuth2에다가 JWT를 도입해서,  OAuth2 인증 서버와의 통신을 최소화 하고, 프론트 <-> 백엔드 간에만 통신하도록 구성하기로 했습니다.

앞서 말씀드렸던 말 중에, 크게 다르지 않을것이라고 판단했던 것은 제 큰 오산이었습니다. Spring Security + OAuth2 + JWT까지 접목을 하기에는 어떻게 해야될지 감조차 오지 않았습니다.

그래서 자신있게 구현을 해보겠다고 말씀을 드렸지만,  조금 학습이 더 필요할것 같다. 최대한 빨리 학습하고 구현까지 해보겠다고 양해를 구했습니다.

그래서 그 때부터, 관련 내용들에 대해 깃 레포지토리의 베스트 프랙티스들을 찾아보았고, 그걸 이제 클론해와서 디버그 포인트를 걸고 어떻게 작동하는지에 대해 계속 돌려봤습니다. 

동시에, 스프링 시큐리티 인 액션이라는 책을 구매해서 읽어보았구요, 또한 스프링 시큐리티는 공식문서 만한게 없다고 들어서 공식문서의 아키텍처 부분을 자세히 읽어보기 시작했습니다.

그렇게 학습을 해서, 큰 그림을 알게 되었고, 거기서 제가 어떤 위치에 무엇을 설계해야 Spring Security + OAuth2 + JWT라는 아키텍처를 구현할 수 있을지 알게되었습니다.

그래서, 다음과 같이 설계를 했는데요.

먼저, 회원이든 비회원이든 로그인 요청을 하게 될 경우, OAuth2 인증 로직이 트리거 됩니다. 인증을 받게된 후에는, SuccessHandler를 하나 추가했습니다. 그 핸들러에서, DB에서 회원 여부를 판단한 후에, 회원이 아니면 url 파라미터에 회원이 아니라는 값을 넣어서 프론트로 리디렉션을 시켜주도록 구성했습니다.

회원이라면, JWT 형식인 AccessToken을 발급하고, 이를 url 파라미터에 담아서 프론트로 리디렉션 시켜주었습니다.

이 때 JWT AccessToken은 hmacSha 알고리즘을 이용해 만든 비밀 키로 서명을 했구요, 서명을 하는 알고리즘은 HS256보다 HS512가 64비트에서 좀 더 빠르다고 해서 512를 사용했습니다. 
그리고,  현재 인증 유저의 OAuth2 인증 후 유저의 정보를 조회하면 나오는 Id값이 있는데, 그 값을 유저 식별자로써 사용을 하기로 했고, 해당 값을 AccessToken의 claim에 저장하였습니다. 만료 시간은 30분 정도로 구성했습니다.

비회원이 회원 가입을 하면, 아직 비회원은 OAuth2 인증을 받은 상태입니다. 그렇기 때문에, 회원 가입 요청 시, 컨트롤러에서 UserDetails인 OAuth2User를 파라미터로 받아서 사용할 수 있습니다. 그래서 해당 정보에서 회원의 id값과 나머지 정보들을 조회하고, 그 정보를 기반으로 회원 엔티티를 생성해서 리포지토리에 저장하도록 구성했습니다. 또한, JWT를 발급 해주고, JSON  형태로 프론트엔드 서버에 내려주도록 구성했습니다.

JWT를 발급받으면, 해당 토큰으로 인증되도록 필터를 구성했기 때문에, 글작성, 수정, 삭제 로직에 접근할 수 있게 됩니다. 또한, 회원가입 요청은 해당 필터를 거치지 않도록 `oncePerFilter`의 `shouldNotFilter`메서드를 이용했습니다.

필터에서 JWT의 유효성을 평가하고, 유효할 경우, JWT를 파싱해서 claim에 있는 authId를 Username으로 하는 UserDatails를 생성하고, UsernamePasswordAuthenticationToken으로 변환해서, Security Context에 등록합니다.

보통 리프레시 토큰도 사용하지 않니?
처음에는 저희도 리프레시 토큰을 도입하기로 했습니다. 다만, 저희가 토론한 끝에, 리프레시 토큰이 어차피 프론트단에 내려가면서 노출이 될 수 밖에 없는 환경에 놓여있다면, 보안 상 문제가 있을 수 있으니, 차라리 AccessToken만 만료 시간을 30분정도로 발급을 해주고 만료시 재 로그인을 요청하자는 쪽으로 결정을 했습니다.


## 기능 구성 - 비즈니스 로직 관련

게시글 관련해서는 기본적인 CRUD와 페이징, 서칭, 상태 변경을 구현했습니다. 

특히, 글 작성, 글 수정, 글 삭제는 JWT 액세스 토큰을 가진 유저만 할 수 있도록 구성해야 했고, 이는 스프링 시큐리티의 인증 객체를 Controller의 파라미터에서 받으므로써 해결했습니다.  초기에는 파라미터를 Authentication으로 함으로써 다형성을 고려하여 설계를 했는데, 이렇게 할 경우 파라미터에 OAuth2인증만 한 유저도 접근을 할 수 있게 됩니다. 

그래서, 차라리 OAuth2인증자가 요청을 보내면 에러를 발생시키기로 했고, 결국 파라미터는 UsernamePasswordAuthenticationToken으로 좀 자세한 객체를 사용하였습니다. 해당 객체에서  getName()을 하면 authId가 나오도록 설계했기 때문에, 해당 Id로 유저를 조회하여 비즈니스 로직에 사용합니다.

작성, 삭제, 수정은 인증 객체를 이용한다는 것 말고는 특이사항이 없습니다.

단건 조회도 인증 유저 정보를 받긴 합니다만, 이는 단순히 글 작성자인가를 판단하는 불리언 값을 내려주기 위함입니다. 이 때는 Authentication 으로 받으므로써 인증 유형에 상관 없이 받도록 구성했고, 인증이 되지 않은 유저도 조회가 가능해야 했으므로, authentication이 null일 경우 authId대신 빈 스트링값을 줌으로써, 글 작성자인지 아닌지에 대한 판별값이 무조건 false가 나오도록 설계했습니다.

여러건 조회는 페이저블 객체를 받음으로써 편리하게 페이징이 되도록 했습니다.

서치가 문제인데요. 제가 엔티티 관계 매핑을 N:1 - N:1 로 구성을 했기 때문에, 서치 로직에 문제사항이 생겼습니다. 해당 로직은, 페이징까지 적용해야 하기 때문에 페치 조인도 사용할 수 없었습니다. 물론, 저 관계에서 페치 조인을 할 경우 예외가 터지기도 합니다.

> 페이징 + 페치조인이 안되는 이유? 아예 안되진 않는다.
> - OneToMany나 OneToOne 처럼 페치 조인 해도 데이터 개수가 변하지 않는 경우는 괜찮다.
> - 하지만, ManyToOne이나 ManyToMany와 같은 관계는 페치 조인 + 페이징을 사용할 수 없다. 이유는 조인을 하면 데이터 수가 변하기 때문이다.
> 	- 위 경우, 내가 겪었듯이 메모리를 사용해서 페이징을 적용하기 때문에, 장애의 요인이 될 수 있다.

그래서 방법을 찾다가, batch_fatch_size라는 옵션을 알게 되었고, 이를 적용하면 한번에 몇개를 가져올 것인지 설정해주는 옵션이기 때문에, N+1 문제가 발생하지 않고, 각각 설정 개수만큼 한번에 가져오게 됩니다. 제 경우에는, 3개의 엔티티를 조회하므로, 해당 로직에서 3개의 쿼리가 날아가는 것을 확인할 수 있었습니다.


## 기술 선택의 이유

### 자바 + 스프링 부트
한국은 자바공화국이라고 불릴 만큼 자바의 수요가 많기 때문입니다. 수요가 많다는 것은, 국내 커뮤니티 등에서 많은 도움을 요청할 수 있다는 것과 동일한 의미라고 판단하였습니다. 

저는 특히 혼자 공부를 했기 때문에, 제가 막혔을 때 도움을 많이 받을 수 있는 언어가 필요했습니다. 이런 점 때문에, 한국어 강의는 기본적으로 자바가 가장 잘되어있었고 덕분에 공부하는 데 수월했던 것 같습니다.

### 스프링 시큐리티
물론, 자바 혹은 스프링부트의 Filter, Interceptor 기능을 이용하여 인증과 인가를 구현할 수는 있습니다. 다만, 아직 주니어인 제가 그걸 이용해서 처음부터 시스템을 구성하면 보안에 상당히 취약할 것이라고 생각했습니다.

그래서, 인증/인가를 손쉽게 지원해주는 스프링 시큐리티 프레임워크를 사용하기로 했습니다.

### OAuth2
스프링 시큐리티의 UsernamePassword 인증 방식을 구현하면, 사이트 내 회원 가입과 인증 로직을 사용할 수는 있습니다. 

다만, 해당 방식으로 직접 구현할 경우, 로그인 페이지부터 로그아웃 페이지, 그리고 회원가입 페이지, 비밀번호 확인, 비밀번호 찾기, 아이디 찾기 등 생각보다 많은 기능을 구현해야 했습니다.

그래서 좀 더 간편한 인증 방식인 OAuth2를 도입하기로 했습니다. 모든 유저를 만족시킬 수는 없겠지만, 그래도 유저가 회원가입에 좀 더 접근하기 수월하도록 OAuth2 Provider는 구글, 깃허브, 네이버, 카카오 총 4개를 제공하기로 했습니다.

OAuth2 인증 로직 구현은 Spring boot가 제공하는 OAuth2 client 프레임워크를 사용하였습니다.


### JWT
OAuth2 인증은 구글 등 Provider의 Authorization server, Resource server와 통신함으로써 인증됩니다. 

하지만, 우리의 웹 앱은 프론트 서버와 백엔드 서버가 서로 API 통신을 하는 구조로써, OAuth2Provider들과 통신을 한번 더 하는것이 상당히 비효율적이라고 판단했습니다.

그래서, 첫 인증 후 나머지 인증 과정을 프론트와 백엔드 사이에서만 수행하기 위해, 도입하기로한 것이 JWT입니다. 

저희는 AccessToken만을 사용하기로 했습니다. RefreshToken이 액세스 토큰의 재발행을 도와주는 역할을 하지만, 어찌됐든 프론트 서버에 한번은 내려줌으로써 외부 노출 가능성이 존재한다고 생각합니다. 

그렇기 때문에, 리프레시 토큰을 사용하는 대신, AccessToken의 수명을 30분 정도로 하고, 만료 시 로그인을 다시 하라는 페이지로 보내 유저의 재 로그인을 유도할 계획입니다.


### AWS
예전에 Heroku라는 배포 툴을 이용해서 디스코드 봇을 한번 배포해본 경험이 있습니다. 이 때는 그냥 "올리면 배포가 되는구나. 쉽네"라고만 생각했습니다.

하지만,  몰랐던 배포 과정을 상세하게 알 필요는 있다고 생각해서, 이번에는 AWS를 사용하여 수동 배포를 해보기로 했습니다. 

부가적으로, 1년 무료이기도 했고, 국내 커뮤니티가 잘 되어있다는 말을 들어서 AWS를 선택한 이유도 있습니다.

#### EC2, RDBMS
AWS 무료 프리티어 기준에서 사용할 수 있는 컴퓨터인 EC2와 RDBMS를 사용해보기로 했습니다. RDBMS는 그 중에서도, MariaDB를 사용했는데, 오픈소스이고, 동일 하드웨어 사양일 때 MySQL보다 성능이 좋다는 점, 그리고 커뮤니티가 좀 더 활성화되어있다는 것이 선택 이유였습니다.

#### GitHub Actions - S3 - CodeDeploy 
CI 툴로써, 젠킨스와 GitHub Actions 중에서 무엇을 사용할지 좀 고민을 하다가 결국 깃허브 액션을 사용하기로 했는데, 가장 큰 이유는 제가 한번 사용해본 경험이 있어서 스크립트를 작성하기가 수월하다는 점 때문이었습니다.

인증/인가 구현에 상당히 많은 시간을 써버렸기 때문에, 프론트엔드 개발자분의 기능 테스트를 위해, 일단 선 배포가 중요했습니다.

그래서 많이 익숙한 GitHubActions를 CI 툴로 사용했습니다.

CD 툴로는 CodeDeploy를 사용했는데, 주 목적은 CI와 CD를 분리하기 위해서였습니다. 분리하면 빌드 없이 배포만 필요할 때 Jar를 재사용하기만 하면 되기 때문입니다.

CodeDeploy는 저장 기능이 없습니다. 그렇기 때문에, S3버킷 이라는 일종의 파일 서버를 사용해야 합니다. 

CI 툴인 깃허브 액션이 빌드와 테스트를 하고, 통과 시 S3에 jar 파일을 전달하도록 설정했습니다. 그 후, S3에 저장된 jar파일을 CodeDeploy로 전달하여 배포를 진행하도록 스크립트를 구성하였습니다.

### Nginx
저렴하고 쉽게 무중단 배포를 하기 위해 사용했습니다. 도커를 이용한 무중단 배포도 고려를 했으나, 러닝 커브를 생각해서 엔진엑스를 선택했습니다. 일단 선 배포를 한 후, 추후에는 도커를 이용하여 무중단 배포를 구성해볼 계획입니다.


### JavaScript, JQuery, Ajax
서버사이드 렌더링을 이용할 때, 입력 데이터에 대해 API 형식으로 전송 해보고자 도입하였습니다.  간단한 데이터 전송용으로 사용했습니다.


### JPA, QueryDSL
SQL 매퍼는 사용해본 경험이 없기도 하고, SQL에 의존적인 개발을 할 수 밖에 없다는 점 때문에 사용을 고려하지 않았습니다. 그래서, 자바 표준 ORM인 JPA를 사용하기로 결정했습니다. 

그리고, 조건에 따른 검색 기능을 구현하기 위해, 동적 쿼리를 구성해야 했기 때문에, 좀 더 구성이 편한 QueryDSL을 사용하였습니다.
