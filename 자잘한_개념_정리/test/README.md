# Test 관련 내용 정리
## 테스트 코드가 없으면...
- 불안에 떨며 릴리즈
- 긴 릴리즈 주기 
- 생산성 저하 

## 테스트 코드 장점 
- 자신감 있게 릴리즈 가능  
- 생산성 향상
- 좋은 아키텍처 유도 (테스트 하기 좋은 코드)
  - SOLID한 코드가 좋은 설계일 확률이 높다  
  - Test와 SOLID는 긴밀한 상관 관계를 가진다 (상호 보완적)
- 회귀 버그를 방지 
- 테스트를 명료하게 작성하도록 노력하면, 단일 책임 원칙이 지켜질 확률이 높다 
  - 테스트 클래스에 테스트가 많아지면.. 목적이 눈에 안들어옴 → 클래스 책임이 과하다는 신호 → 클래스 분할 
- 테스트를 작성하다 보면, 개방 폐쇄 원칙을 지키게끔 코드를 작성할 수밖에 없다
  - 테스트 작성을 위해서는 테스트용 컴포넌트와 프로덕션용 컴포넌트를 나눠서 작성 → 선택적으로 탈부착이 가능해야함  
  - 자연스럽게 개방 폐쇄 원칙을 지키게 됨 
- 리스코프 치환 원칙을 지키는지도 확인 해줌 
  - 이상적으로 테스트는 모든 케이스에 대해 커버하기 때문 
- 테스트는 그 자체로 인터페이스를 사용할 수 있는 환경 
  - 불필요한 의존성을 실제로 확인할 수 있는 샌드박스 
  - "인터페이스가 너무 많아서, 뭘 호출해야할지 모르겠는디?" → 인터페이스를 분리해줘야 하는 시점
- 테스트는 의존성 역전 원칙을 지키게 유도해준다 
  - 가짜 객체를 이용하여 테스트하려면, 의존성이 역전되어 있어야 하는 경우가 생기기 때문 (Fake, Dummy...)

## Regression
- 잘 돌아가던 코드가 배포로 인해 동작하지 않는 상황

### 회귀 버그
- 서비스를 제공하지 못하던 상황으로 회귀하는 상황 

### 회귀 테스트
- 서비스에 회귀 버그가 있는지를 확인하는 테스트

## 인수/자동 테스트 
### 인수 테스트
- 인수 검사란?
  - 정보 시스템 검사 중 하나. 
  - 시스템이 실제 운영 환경에서 사용할 준비가 되었는지 최종적으로 확인하는 단계 
  - 시스템 검사는 사용자가 평가하고 관리자가 점검

### 자동 테스트 
- 소프트웨어를 이용하여 자동화된 테스트 

---

## 테스트의 3분류 
### API 테스트 (E2E)
- 멀티 서버
- End to end 테스트 
- 테스트 결과가 상대적으로 불안정함 
  - 예상치 못한 이유로 실패할 수 있음  

### 통합 테스트
- 단일 서버
- 멀티 프로세스 
- 멀티 스레드 
- 테스트용 DB를 사용할 수 있음
  - H2와 같은 DB를 사용할 수 있음 
- 단위 테스트보다 느리고, 멀티 스레드 환경에서 어떻게 동작할지 알 수 없기 때문에 테스트가 결정적이지 않아 결과가 보장되지 않음
  - H2와 같은 외부 모듈의 동작에 따라 달라지기 때문 

### 단위 테스트 
- 단일 서버 
- 단일 프로세스
- 단일 스레드 
- 디스크 I/O를 사용하지 않음
- Blocking call을 허용하지 않음 
- 테스트가 항상 결정적이고 빠름
  - 이런 테스트를 여러개 만들어서 코드 커버리지를 높이자 
  - 단위 테스트를 늘릴 수 있는 환경을 만들고, 늘려야 한다 


## 테스트 관련 용어 
### SUT
- System under the test (테스트 하려는 대상)

### TDD
- 테스트 주도 개발 
- 방법
  1. 깨지는 테스트를 먼저 작성한다
  2. 깨지는 테스트를 성공시킨다
  3. 리팩토링한다

### BDD
- Behaviour driven development (given-when-then)
- 시나리오에 기반한 테스트를 수행하는 방식 
  - 어떤 상황이 주어지고, 어떤 행동을 할 때, 이렇게 되더라 

### 불규칙한 테스트 (flaky)
- 대상 코드에 아무런 변경이 없음에도 불구하고 실패하는 테스트

### 깨지기 쉬운 테스트 (brittle)
- 실제로는 버그가 없음에도, 심지어 검증 대상 코드와 관련조차 없는 변경 때문에 실패하는 테스트 
- 테스트에 필요한 가정들이 명시적으로 작성되어있지 않을 경우 발생

### 상호 작용 테스트 (interaction test)
- 대상 함수의 구현을 호출하지 않으면서, 그 함수가 어떻게 호출되는지를 검증하는 기법
- 일반적으로 상태를 테스트하는 것이 더 좋은 방법

### 테스트 픽스처
- 테스트에 필요한 자원을 미리 생성 해두는 것 
  - fixture: 비품, 설비 
- sut가 될 수도 있고, sut에 들어가야 하는 의존성 일부가 될 수도 있음 
- 단점 
  - 테스트 픽스처를 과하게 사용할 경우, 테스트가 한 눈에 들어오지 않음

### 비욘세 규칙 (feat. 구글)
- 네가 나를 좋아했다면, 프로포즈를 했어야지 
  - 상태를 유지하고 싶었다면, 테스트를 만들었어야지 
- 즉, 유지하고 싶은 상태나 정책이 있다면, **알아서 테스트를 만들어야 한다**는 뜻
  - 유지하고 싶은 상태가 있다면, 전부 테스트를 작성하세요!
  - ex: 유저 아이디가 email 형식을 따르고 있다면, 이에 대한 테스트를 작성하세요 (예외 상황까지)
  - ex: 마일리지 쿠폰이 5만원 이상일 때만 사용 가능하게 하고 싶다면, 이에 대한 테스트를 작성하세요 (예외 상황까지) 
  - 이런게 모여서 시스템의 정책이 됩니다 
- **테스트는 정책이고 계약이다** 
  - 설명 보다는 테스트를 보여주면 됨  
  - 테스트는 문서다! 프로그램이 지켜야 할 계약과 같은 것! 

### Testability
- 테스트 가능성
- 당신의 소프트웨어가 테스트가 가능한 구조인가?

### 테스트 더블 
- Test double = 테스트 대역 
- 가짜 객체를 의미 

### Dummy  
- 아무런 동작도 하지 않고, 그저 코드가 정상적으로 돌아가기 위해 전달하는 객체 

### Fake  
- Local에서 사용하거나 테스트에서 사용하기 위해 만들어진 가짜 객체
- 자체적인 로직이 있다는 것이 특징 
  - 그 자체로 Fake객체 만의 일을 한다
  - ex: real Repository는 DB에 진짜 저장 | Fake Repository는 ArrayList 등을 이용해 메모리에 저장  
- 잘 만들어진 Fake 객체는 로컬 개발에서도 사용할 수 있음 

### Stub
- 미리 준비된 값을 출력하는 객체 
  - 특정 로직은 없음. 값을 만들어서 반환만 해줌 
- 주로 외부 연동하는 컴포넌트들에 많이 사용 
- 주로 Mockito 프레임워크 이용 

### Mock
- 메소드 호출을 확인하기 위한 객체
- 자가 검증 능력을 갖춤 
- 사실상 테스트 더블과 동일한 의미 

### Spy
- 메소드 호출을 전부 기록했다가 나중에 확인하기 위한 객체 
  - 몇번 호출됐는지, 잘 호출됐는지 등 

### Mock 프레임워크 
- 가능하면 사용은 지양하는게 좋음 
- UserRepository를 인터페이스로 구현한 경우
  - UserRepository가 굳이 인터페이스여야 할 이유가 있나? 그냥 class로 만들고 mock 프레임워크를 사용해서 필요할 때마다 stub하면 되지 않나?
  - 이러한 유혹에 빠지면 안됨 
  - 테스트 코드를 작성하는 것 자체가 목적이 되어버림 -> **자연스러운 추상화를 통한 유연한 설계를 얻을 기회**를 놓치게 됨
- 테스트 코드의 목적을 잊지 말자  
  - 회귀 버그 방지
  - 유연한 설계 

---

## 의존성과 Testability
### 의존성 
- 결합(Coupling)과 같은 개념 
  - A가 B를 사용하기만 해도 A는 B에 의존한다고 할 수 있다
- 의존성을 약하게 만드는 대표적인 방법 중 하나가 **의존성 주입**이다
  - 완전히 없애는 것은 아니다
  - `new`는 사실상 하드 코딩이다 
- 의존성을 제거한다 == 객체/시스템 간 협력을 부정한다
  - 즉, 완전히 없앨 수는 없다 
- 어떻게 하면 의존성을 약화시킬 수 있을까를 고민할 것 

### 의존성 역전
- 의존성 주입과는 완전히 다른 개념임을 인지하자
- 규칙 
  - 상위 모듈은 하위 모듈에 의존하면 안된다 
    - 상위 모듈과 하위 모듈은 모두 추상화에 의존해야 한다 
  - 추상화는 세부 사항에 의존해서는 안된다
    - 세부사항이 추상화에 의존해야 한다 
- 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다 
  - 세부 사항이 정책에 의존해야 한다 
  - 자바와 같은 정적 타입 언어에서, `import` 구문은 오직 인터페이스나 추상 클래스와 같은 추상적인 선언만을 참조해야 한다는 뜻이다 
  - 구체적인 요소는 변동성이 크다. 이에 의존하지 말자.
- 대부분의 소프트웨어 문제는 의존성 역전으로 해결이 가능하다 

### 의존성과 테스트 
- 테스트를 잘하려면 의존성 주입과 의존성 역전을 잘 다룰 수 있어야 함 
  - 의존성이 숨겨져 있으면 좋지 않은 신호
  - 테스트하기 어렵게 만듬
  - 그러니 의존성 주입으로 의존성을 드러내자 
- 대신...
  - 구체적인 것에 의존하지 않게 해야한다
  - 구현체에 의존하게 하면, 어딘가는 또 테스트가 어려워지게 된다 
  - 그러니 인터페이스를 만들어서 의존해야, 테스트하기가 더 쉬워진다 

### Testability
- 테스트 가능성
  - 얼마나 쉽게 input을 변경하고, output을 검증할 수 있는가
- 테스트가 어려운 케이스 (낮은 Testability)
  - input
    - 하드코딩 된 경우 (ex: 파일 이름)
    - 하드코딩 된 외부 시스템과 연동된 경우
      - service에서 webClient, restTemplate와 같은 것을 직접 사용하는 경우 -> 테스트 핵 어려움 
  - output
    - 외부에서 결과를 볼 수 없는 경우 (ex: 콘솔에 출력을 해버리는 경우)

---

## 조언 
### private 메소드는 테스트해야 하나?
- NO
- private 메소드를 테스트하고 싶은 느낌이 들 때...
  - 사실 private 메소드가 아니었어야 한다는 의미일수도 
  - 해당 메서드를 다른 클래스로 분리하고, 책임을 위임해서 public으로 만들라는 의미일수도
- 이는 메소드 지향의 테스트를 할 때 자주 발생하는 문제이다
- 테스트는 **행위에 집중해서**테스트를 하자 

### final 메소드를 stub해야 하는 상황이 발생한 경우 
- 무언가 설계가 잘못된 것 
- final 메소드에 걸린 의존성을 약하게 하는 방법을 생각해야 함 

### DRY < DAMP
- 테스트 코드는 DRY 보다는 DAMP!
  - DRY: Don't Repeat Yourself (반복하지 않기)
  - DAMP: Descriptive And Meaningful Phrase (서술적이고 의미있는 문구)
- 테스트할 때 만큼은 중복을 줄이는 것 보다는 테스트 하나하나마다 독립적이고, 서술적이며 의미있는 코드를 작성하는 것이 낫다  


### 논리
- 테스트에 논리를 넣지 말자 
  - for/if/사칙연산 등을 넣지 말자는 의미
- 테스트 코드가 오래, 그리고 많이 실행되려면 직관적이고 바로 이해가 가능하게 짜는 것이 좋다 


---

## 기법 
### 의존성 추상화 
- 테스트하기 어려운 의존성이 있을 때 사용 가능한 기법 
- 다루기가 까다로운 경우(Random, Time...) 
```mermaid
classDiagram
  User-->ClockHolder
  SystemClockHolder--|>ClockHolder
  SystemClockHolder-->Clock
``` 

- 테스트에 필요한 인스턴스를 생성하기 힘든 경우 (HttpRequest...)
```mermaid
classDiagram
  ClientIpResolver-->HttpRequestWrapper
  RealHttpRequestWrapper--|>HttpRequestWrapper
  RealHttpRequestWrapper-->HttpRequest
``` 

- 재정의가 까다로운 경우 (final, 전역 참조...)
```mermaid
classDiagram
  MyService-->Global
  SystemGlobal--|>Global
```


### 이벤트 기록 
- 테스트를 위한 getter 생성이 남발된다 싶을 때 
- 호출된 메서드의 이벤트를 기록 

---

## 테스트와 `@Builder`
### 장점 
- 생성자를 하나로 관리 
- 긴 파라미터를 정리 
- 테스트에 Builder를 적극적으로 활용할 경우, 생성자에 파라미터가 추가되어도 컴파일 에러가 나지 않게 됨 (영향 X)

### 단점
- 필요한 파라미터를 누락해도 캐치할 수 없음 (컴파일 에러가 발생하지 않음)