# Run-Time Data Areas

JVM은 프로그램 실행 중에 사용되는 다양한 런타임 데이터 영역을 정의함 

- JVM 시작 시 생성 → 종료 시 삭제되는 영역 (JVM과 라이프 사이클이 같음)
- 스레드 시작 시 생성 → 스레드 종료 시 삭제되는 영역  (스레드와 라이프 사이클이 같음)

## PC register

- JVM은 한 번에 많은 실행 스레드를 지원함
- 각 스레드에는 고유한 ProgramCounter 레지스터가 있음
- 네이티브 메서드가 아닌 경우, PC 레지스터에는 현재 실행 중인 JVM 명령의 주소가 포함됨
    - 네이티브 메서드에 대한  JVM의 PC 레지스터 값은 정의되지 않음
- JVM의 PC레지스터는 특정 플랫폼의 네이티브 포인터나 returnAddress를 보유할 수 있을 만큼 충분히 넓음
    - returnAddress : jsr, jsr_w, ret 명령어를 포함하는 현재 바이트코드의 위치
        - 해당 명령 바로 뒤에 바이트 코드 위치를 나타내는 데 사용됨 → 해당 위치에서 다시 시작 가능

## JVM Stacks

- 스레드 간 공유하지 않음. (스레드마다 새로 할당)
- 프레임을 저장함 (스택 프레임)
- 지역 변수와 부분 결과(partial results)를 가짐
- 메서드 호출 및 반환 역할을 함
- 프레임 push & pop을 제외하고는 직접 조작되지 않음. → 프레임이 힙에 할당될 수 있음
- 스택의 메모리는 연속적으로 할당될 필요가 없음
- 고정 크기 or 확장/축소
    - 고정 크기일 때 스택 크기 오버 → stackOverflow
    - 가변 크기일 때 메모리 오버 → OutOfMemory

## Heap

- 스레드 간 공유
- JVM이 시작할 때 생성 됨
- GC의 대상이 되는 공간
- 크기 고정 or 가변 크기 가능
- 힙의 메모리는 연속적으로 할당될 필요가 없음
- OutOfMemory

## Method Area

- 스레드 간 공유
- 컴파일된 코드를 저장하는 공간 혹은 OS의 텍스트 세그먼트와 유사함
- 다음의 정보를 저장함
    - 클래스 및 인터페이스 초기화와 인스턴스 초기화에 사용되는 특수 메서드
    - 런타임 상수 풀
    - 필드 및 메서드 데이터
    - 메서드 및 생성자 코드와 같은 클래스 별 구조
- 가상머신 시작 시 생성됨
- 논리적으로 힙의 일부이나, GC나 compact같은 동작을 선택하지 않을 수 있음
- 메서드 영역의 위치나 컴파일된 코드를 관리하는 데 사용되는 정책이 요구되지 않음
- 고정 크기 or 확장/축소 가능
- 연속적으로 메모리가 할당될 필요가 없음
- OutOfMemory

## Run-Time Constant Pool

- 클래스 파일에 존재하는 constant_pool 테이블의 클래스 별 or 인터페이스 별 런타임 표현
- 여러 종류의 상수가 포함됨
    - 컴파일 타임에 알려진 숫자 리터럴
    - 런타임에 확인되어야 하는 메서드 및 필드 참조
- 각 런타임 상수 풀은 메서드영역에서 할당 됨
- 클래스 또는 인터페이스에 대한 런타임 상수 풀
    - JVM에 의해 클래스 또는 인터페이스가 생성될 때 구성 됨

## Native Method Stacks

- 네이티브 메소드(C언어 등으로 구현된)를 지원하기 위해 제공하는 메서드 스택
- JVM 명령 세트에 대한 인터프리터 구현에 의해 사용될 수도 있음
- 네이티브 메서드를 사용하지 않는 JVM은 네이티브 메서드 스택을 제공할 필요가 없음
- 각 스레드가 생성될 때 스레드별로 할당 됨
- 크기 조절 가능
- StackOverFlow
- OutOfMemory
