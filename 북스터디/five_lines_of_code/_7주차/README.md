# 11. 코드 구조 따르기 
## 11.1 코드 구조에 영향을 미치는 것들
- 콘웨이 법칙  
  - 조직의 의사소통 구조는 조직이 만들어내는 소프트웨어의 구조에 영향을 미친다
- 사용자의 행위
  - 일부 코드 구조의 변경은 사용자의 행위 변경도 필요함 
  - 리팩터링 관점에서, 사용자 또한 신경써야 할 요소임 (리팩터링을 제약하는 요소)
  - 책에서 의미하는 사용자의 행위란 무엇인가? 
    - 우리의 서비스를 사용하는 사용자를 의미하는가
      - 그렇다면, 유스 케이스를 말하는건가..?


## 11.2 행위를 코드화 하는 세 가지 방법
- 제어 흐름 사용 
  - 제어 연산자, 메서드 호출 등을 통해 행위를 코드화
  - `if`문, `for`문 등을 이용하여 행위를 구현하라는 의미인 것 같음 
- 데이터 구조 사용
  - 데이터 구조를 이용하여 행위를 코드화
  - 아마 알고리즘, 자료 구조 등을 이용하여 행위를 구현하라는 의미인 것 같음 
  - 예시로 재귀함수가 사용됐는데, stack over flow 에러때문에 실무에서는 지양되지 않던가..? 
- 데이터 자체 사용 
  - 이 구조는 사용하지 말라는데, 어떻게 사용해야 하는지도 이해하지 못했다 
  - 그냥 배열에 객체넣고 쓰는걸 말하는건가...? 아무튼 컴파일러의 지원을 받지 못하니 쓰지마랜다.
    - 자바에서는 List에 제네릭을 사용하면 될 것 같은데, List에 어떠한 행위를 넣고 구현하는 경우가 어떤 경우가 있으려나.. 생각해보니 아래의 경우가 있을 것 같다
    ```java
    @Service
    class SomeService {
        private final List<SomeStrategy> strategies;
    
        public SomeService(List<SomeStrategy> strategies) {
            this.strategies = strategies;
        }
    
        void someMethod(String type) {
            strategies.stream()
                .filter(strategy -> strategy.supports(type))
                .forEach(strategy -> strategy.doSomething());
        }
    }
    
    interface SomeStrategy {
        boolean supports(String type);
        void doSomething();
    }
    
    @Component
    class SomeStrategyImpl implements SomeStrategy {
        private String supportType;
    
        @Override
        public boolean supports(String type) {
            return supportType.equals(type);
        }
    
        @Override
        public void doSomething() {
            System.out.println("doSomething");
        }
    }
    ```


## 11.3 구조 노출을 위한 코드 추가
- 리팩터링은 현재 구조를 강화하고, 유사한 변경 사항을 더 잘 수용할 수 있게 함 
  - 일관성이 있어야 한다 
  - 예상하는 위치에 변형점을 두도록 한다 (결합도를 낮추고, 응집도를 높여 변경 여파 최소화?)
- 기본 구조에 확신이 있을 때만 리팩터링을 하자 
  - 확신이 없다면 먼저 정확성에 집중해야 한다 
- 테스트 코드가 이러한 불확실성 해소에 어느정도 도움을 줄 수 있을 것 같다 

## 11.4 예측 대신 관찰, 그리고 경험적 기술 사용 
- 변경 범위를 예측할 때, 추측하지 말고 경험적 기술을 사용하라 
  - 증거 기반 관리(Evidence-based management)
  - 팝콘 플로우(폭발적인 변화를 일으키는 작은 변화)
- 강력한 도구가 있더라도 항상 사용하는 것은 옳은 방법이 아닐 수 있다 
  - 변경되지 않으면 아무것도 하지 마라 
  - 예측할 수 없이 변경되는 경우, 취약성을 피하기 위한 리팩터링만을 수행하라 
  - 과거에 발생한 변경 유형을 적용해 리팩터링 하라 
- 항상 확장 가능한 코드를 짜야만 하는가? 
  - 얼마 사용되지 않을 코드는 하드 코딩으로..? 
  - 변경이 발생하지 않을 코드는 하드 코딩으로..? 하지만 변경이 발생하지 않음을 가정하는 것이 옳은 방향인가? 
    - ex: 변경이 발생되지 않을거라 확신한 주민등록번호는 개인정보 보호법이 강화되면서 저장하지 못하는 형태로 변경되었다. 이를 PK로 사용하던 업체들은 절망을 했다는 썰이 있음. 
      - 위 썰을 통해, 정말 변경이 없었던 것들이, 추후에도 과연 변경되지 않을 것이라고 확신할 수 있는가에 대한 의문이 든다.
      - 그렇다면 어느 정도로 확장 가능하게 짤것인가? 아래의 방법이 좋으려나.. 
        - 먼저 변경 가능성을 고려하지 않고, 요구사항대로만 짠다 
        - 변경이 발생하면 리팩터링을 통해 변경을 수용할 수 있도록 한다 (발생할 때 까지 일단은 변경 가능성을 고려하지 않는다.)
        - 다만, 패키지 의존성과 레이어 간 의존성 등은 항상 고려하는게 좋지 않을까? 이는 테스트가 쉽게 만드는 데 중요한 역할을 하기 때문이다. 아무리 변경 가능성이 없는 코드여도, 테스트는 반드시 있어야 하고 테스트하기 쉬운 코드를 작성하는 것은 중요한 것 같다. 즉, 의존성을 역전하기 위한 인터페이스 설계는 소홀히 하면 안될 것 같다. 
        

## 11.5 코드를 이해하지 않고도 안전성을 확보하는 방안  
- 테스트 자동화 
- 리팩터링을 작은 단계로 분할 후 반복적으로 수행 
- IDE 이용 (메서드 추출 작업 등을 편하게 수행)
- proof assistant를 사용하여 프로그램의 논리적인 명제가 올바른지 기계적으로 확인 할수도 있음 
- 오류가 발생하더라도 자체 수정하도록 코드를 작성(기능 토글)


## 11.6 활용되지 않은 구조 이용 
- 도메인, 의사소통 방식, 사고방식과 같은 구조는 코드에 스며들게 됨 
- 도메인은 소프트웨어보다 오래된 경향이 있으므로, 더 성숙하며 급격한 변화가 덜 발생함 
  - 따라서, 도메인으로 부터 온 구조는 안전하게 사용할 수 있는 편임 
- 프로세스와 팀은 소프트웨어보다 수명이 훨씬 짧아 불안정함을 인지해야 함 

### 11.6.1 추출 및 캡슐화에 공백 활용
- 빈 줄을 이용해서 구조를 표현
  - 같은 컨텍스트를 가지는(관련이 있는) 코드끼리 모아둔다 
  - 이를 메서드로 추출한다
    - 메서드가 한 개의 일만 수행하도록 신경쓴다 
  - 이는 클래스로 추출할 때에도 마찬가지다
    - 같은 컨텍스트를 가지는 필드끼리 클래스로 추출 
    - 같은 컨텍스트를 가지는 메서드끼리 클래스로 추출 등 


### 11.6.2 통합에 중복 코드 활용
- 일단 메서드들을 추출한다 
  - 추출한 메서드들이 중복되어 여러 클래스에 분산되어 있을 경우, 메서드에 데이터 캡슐화를 사용하여 한 곳으로 모을 수 있음
  - 보유한 메서드가 동일하면, 해당 클래스도 동일 → 하나만 남기고 삭제 (유사 클래스 통합)
  - 문장의 제어 흐름은 유사하나, 문장 자체가 다른 경우 → 전략 패턴 도입 


### 11.6.3 캡슐화로 공통 접사 활용 
- 나는 `XxxStrategy`, `XxxPolicy`를 많이 활용했는데, 안좋은 방법이려나... 
  - 전략 패턴 관련 네이밍 방식을 어떻게 하고 계신가요?
  - 이름짓기 애매할 때는 그 클래스의 역할이 제대로 됐나를 생각 해보라던데.. 이런 경우도 애매한 케이스이려나요?


### 11.6.4 동적 실행으로 런타임 유형 활용 
- 런타임 바인딩 
  - 런타임에 객체의 타입을 결정하는 것 
  - 런타임에 객체의 타입을 결정하므로, 컴파일 타임에는 타입을 알 수 없음
- 다형성을 활용하라는 말인 것 같음 

---

---

# 12. 최적화 및 일반화 회피

---

---

# 13. 나쁜 코드를 식별 가능하게 만들기 