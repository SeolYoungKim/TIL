# 11. 코드 구조 따르기 
## 11.1 코드 구조에 영향을 미치는 것들
- 콘웨이 법칙  
  - 조직의 의사소통 구조는 조직이 만들어내는 소프트웨어의 구조에 영향을 미친다
- 사용자의 행위
  - 일부 코드 구조의 변경은 사용자의 행위 변경도 필요함 
  - 리팩터링 관점에서, 사용자 또한 신경써야 할 요소임 (리팩터링을 제약하는 요소)
  - 책에서 의미하는 사용자의 행위란 무엇인가? 
    - 우리의 서비스를 사용하는 사용자를 의미하는가
      - 그렇다면, 유스 케이스를 말하는건가..?


## 11.2 행위를 코드화 하는 세 가지 방법
- 제어 흐름 사용 
  - 제어 연산자, 메서드 호출 등을 통해 행위를 코드화
  - `if`문, `for`문 등을 이용하여 행위를 구현하라는 의미인 것 같음 
- 데이터 구조 사용
  - 데이터 구조를 이용하여 행위를 코드화
  - 아마 알고리즘, 자료 구조 등을 이용하여 행위를 구현하라는 의미인 것 같음 
  - 예시로 재귀함수가 사용됐는데, stack over flow 에러때문에 실무에서는 지양되지 않던가..? 
- 데이터 자체 사용 
  - 이 구조는 사용하지 말라는데, 어떻게 사용해야 하는지도 이해하지 못했다 
  - 그냥 배열에 객체넣고 쓰는걸 말하는건가...? 아무튼 컴파일러의 지원을 받지 못하니 쓰지마랜다.
    - 자바에서는 List에 제네릭을 사용하면 될 것 같은데, List에 어떠한 행위를 넣고 구현하는 경우가 어떤 경우가 있으려나.. 생각해보니 아래의 경우가 있을 것 같다
    ```java
    @Service
    class SomeService {
        private final List<SomeStrategy> strategies;
    
        public SomeService(List<SomeStrategy> strategies) {
            this.strategies = strategies;
        }
    
        void someMethod(String type) {
            strategies.stream()
                .filter(strategy -> strategy.supports(type))
                .forEach(strategy -> strategy.doSomething());
        }
    }
    
    interface SomeStrategy {
        boolean supports(String type);
        void doSomething();
    }
    
    @Component
    class SomeStrategyImpl implements SomeStrategy {
        private String supportType;
    
        @Override
        public boolean supports(String type) {
            return supportType.equals(type);
        }
    
        @Override
        public void doSomething() {
            System.out.println("doSomething");
        }
    }
    ```


## 11.3 구조 노출을 위한 코드 추가
- 리팩터링은 현재 구조를 강화하고, 유사한 변경 사항을 더 잘 수용할 수 있게 함 
  - 일관성이 있어야 한다 
  - 예상하는 위치에 변형점을 두도록 한다 (결합도를 낮추고, 응집도를 높여 변경 여파 최소화?)
- 기본 구조에 확신이 있을 때만 리팩터링을 하자 
  - 확신이 없다면 먼저 정확성에 집중해야 한다 
- 테스트 코드가 이러한 불확실성 해소에 어느정도 도움을 줄 수 있을 것 같다 

## 11.4 예측 대신 관찰, 그리고 경험적 기술 사용 
- 변경 범위를 예측할 때, 추측하지 말고 경험적 기술을 사용하라 
  - 증거 기반 관리(Evidence-based management)
  - 팝콘 플로우(폭발적인 변화를 일으키는 작은 변화)
- 강력한 도구가 있더라도 항상 사용하는 것은 옳은 방법이 아닐 수 있다 
  - 변경되지 않으면 아무것도 하지 마라 
  - 예측할 수 없이 변경되는 경우, 취약성을 피하기 위한 리팩터링만을 수행하라 
  - 과거에 발생한 변경 유형을 적용해 리팩터링 하라 
- 항상 확장 가능한 코드를 짜야만 하는가? 
  - 얼마 사용되지 않을 코드는 하드 코딩으로..? 
  - 변경이 발생하지 않을 코드는 하드 코딩으로..? 하지만 변경이 발생하지 않음을 가정하는 것이 옳은 방향인가? 
    - ex: 변경이 발생되지 않을거라 확신한 주민등록번호는 개인정보 보호법이 강화되면서 저장하지 못하는 형태로 변경되었다. 이를 PK로 사용하던 업체들은 절망을 했다는 썰이 있음. 
      - 위 썰을 통해, 정말 변경이 없었던 것들이, 추후에도 과연 변경되지 않을 것이라고 확신할 수 있는가에 대한 의문이 든다.
      - 그렇다면 어느 정도로 확장 가능하게 짤것인가? 아래의 방법이 좋으려나.. 
        - 먼저 변경 가능성을 고려하지 않고, 요구사항대로만 짠다 
        - 변경이 발생하면 리팩터링을 통해 변경을 수용할 수 있도록 한다 (발생할 때 까지 일단은 변경 가능성을 고려하지 않는다.)
        - 다만, 패키지 의존성과 레이어 간 의존성 등은 항상 고려하는게 좋지 않을까? 이는 테스트가 쉽게 만드는 데 중요한 역할을 하기 때문이다. 아무리 변경 가능성이 없는 코드여도, 테스트는 반드시 있어야 하고 테스트하기 쉬운 코드를 작성하는 것은 중요한 것 같다. 즉, 의존성을 역전하기 위한 인터페이스 설계는 소홀히 하면 안될 것 같다. 
        

## 11.5 코드를 이해하지 않고도 안전성을 확보하는 방안  
- 테스트 자동화 
- 리팩터링을 작은 단계로 분할 후 반복적으로 수행 
- IDE 이용 (메서드 추출 작업 등을 편하게 수행)
- proof assistant를 사용하여 프로그램의 논리적인 명제가 올바른지 기계적으로 확인 할수도 있음 
- 오류가 발생하더라도 자체 수정하도록 코드를 작성(기능 토글)


## 11.6 활용되지 않은 구조 이용 
- 도메인, 의사소통 방식, 사고방식과 같은 구조는 코드에 스며들게 됨 
- 도메인은 소프트웨어보다 오래된 경향이 있으므로, 더 성숙하며 급격한 변화가 덜 발생함 
  - 따라서, 도메인으로 부터 온 구조는 안전하게 사용할 수 있는 편임 
- 프로세스와 팀은 소프트웨어보다 수명이 훨씬 짧아 불안정함을 인지해야 함 

### 11.6.1 추출 및 캡슐화에 공백 활용
- 빈 줄을 이용해서 구조를 표현
  - 같은 컨텍스트를 가지는(관련이 있는) 코드끼리 모아둔다 
  - 이를 메서드로 추출한다
    - 메서드가 한 개의 일만 수행하도록 신경쓴다 
  - 이는 클래스로 추출할 때에도 마찬가지다
    - 같은 컨텍스트를 가지는 필드끼리 클래스로 추출 
    - 같은 컨텍스트를 가지는 메서드끼리 클래스로 추출 등 


### 11.6.2 통합에 중복 코드 활용
- 일단 메서드들을 추출한다 
  - 추출한 메서드들이 중복되어 여러 클래스에 분산되어 있을 경우, 메서드에 데이터 캡슐화를 사용하여 한 곳으로 모을 수 있음
  - 보유한 메서드가 동일하면, 해당 클래스도 동일 → 하나만 남기고 삭제 (유사 클래스 통합)
  - 문장의 제어 흐름은 유사하나, 문장 자체가 다른 경우 → 전략 패턴 도입 


### 11.6.3 캡슐화로 공통 접사 활용 
- 나는 `XxxStrategy`, `XxxPolicy`를 많이 활용했는데, 안좋은 방법이려나... 
  - 전략 패턴 관련 네이밍 방식을 어떻게 하고 계신가요?
  - 이름짓기 애매할 때는 그 클래스의 역할이 제대로 됐나를 생각 해보라던데.. 이런 경우도 애매한 케이스이려나요?


### 11.6.4 동적 실행으로 런타임 유형 활용 
- 런타임 바인딩 
  - 런타임에 객체의 타입을 결정하는 것 
  - 런타임에 객체의 타입을 결정하므로, 컴파일 타임에는 타입을 알 수 없음
- 다형성을 활용하라는 말인 것 같음 

---

---

# 12. 최적화 및 일반화 회피
- 일반화를 해야하는 것은 컨텍스트 뿐임 (코드 ㄴㄴ)
  - 불필요한 일반화를 추가하지 말자 

## 12.1 단순성 추구 
- 단순함을 추구하자 
  - 단순함에 집중하는 것은 소프트웨어 개발의 이상 중 하나임 
- 인간의 인지능력은 제한적이다. 단순함이 필수임. 
  - 일반화를 너무 해버리면 이를 사용하는 곳이 많아진다. 이는 복잡함을 유발하여 머리가 아파진다... 
- 일반화나 최적화가 왜 필요한지에 대한 확실한 증거를 가지고 있어야 한다 


## 12.2 일반화의 시기와 방법
- 하지 않는 일의 양을 최대화 하라 
  - 최소한으로 구축하기 위해 끊임 없이 노력하라 
- 무언가를 만들기 위해서는 컨텍스트(구현하려는 동작의 범위)를 이해해야 함 
- 소프트웨어는 발전함에 따라 요구사항이 변경되는 경향이 있으므로, 일반화를 해버리면 이게 무효화 되어버리는 경우가 많음 
  - 그러니 **당면한 문제만 해결**하자 
- 새로운 것과 오래된 것을 바로 통합하지 말자 
  - 통합 대상이 비슷한 안정성에 도달할 때까지 기다려야 함 
- 불필요한 일반화를 제거하자 


## 12.3 최적화 시기와 방법 
- 필요성이 납득될 때 하자 
  - 성능 테스트가 실패할 때만 최적화 하자 
- 테스트 종류
  - 벤치마크 테스트
    - 이 메서드는 14ms 안에 종료돼야 합니다 
    - 임베디드, 실시간 시스템에서 작성됨 
    - 실 운영환경과 유사한 환경에서만 안정적으로 실행 가능 
  - 부하 테스트
    - 이 서비스는 초당 1,000개의 요청을 처리할 수 있어야 합니다
    - 웹, 클라우드 기반 시스템에서 작성됨 
    - 프로덕션과 같은 하드웨어 필요 
  - 성능 승인 테스트
    - 이 테스트를 실행하면 마지막 실행 시보다 10% 이상 느려지지 않아야 합니다
    - 외부 요인과 완전히 분리 
- 최적화 전 리팩터링
  - 최적화하기 전에 코드가 적절히 리팩터링 됐는지 확인해야 함 
  - 불변 속성을 지역화해서 더 명확하게 만들자 
- 리팩터링 후에도 테스트가 만족스럽지 않으면 최적화를 수행
  - 제약 이론 
    - 병목 지점의 업스트림을 최적화 해봐야 소용없다 (오히려 더 병목이 생김)
    - 다운스트림도 소용 없음. 병목 지점에서 일거리를 안주는데 최적화 해봐야 뭐하나... 
    - 결국, 병목 지점을 최적화 해야한다. 근데 병목 지점이 최적화 되면, 오히려 다운 스트림이 병목 지점이 되거나, 업스트림에서 빠르게 제공 해주지 못하는 불상사가 발생할 수 있다.
  - 리소스 풀링 
    - 사용 가능한 모든 리소스를 공용 풀에 배치 
      - 가능한 최대 용량을 병목 지점에 배치 
      - 로드 밸런서, 스레드 풀링... 
- 측정 지표를 사용한 최적화 
  - 리소스 풀링으로도 해결이 안되면, 병목 지점 내에서 최적화를 해야 함 
  - 코드의 핫 스팟을 식별하고, 해당 부분을 최적화
  - O(n) 지표가 낮다고 해서 모든 상황에 적합한 것은 아님 
    - ex: 퀵 소트가 삽입 정렬보다 O(n) 값이 우수하나, 데이터가 적은 경우에는 삽입 정렬이 더 빠름
- 좋은 알고리즘과 데이터 구조를 선택하자 
- 캐시 사용하기 
  - 멱등적인 불변속성과 조합될 때 가장 안전함
  - 동일한 인자로 호출 시 항상 동일한 결과 제공 
- 최적화된 코드 분리 
  - 튜닝된 코드는 격리하자 
  - 튜닝된 코드의 네이밍은 더욱 더 신경쓰자. 의미를 더 잘 전달할 수 있어야 한다. (문서화 필수)
  - 튜닝된 코드를 위한 전용 패키지를 사용하자. 

---

---

# 13. 나쁜 코드를 식별 가능하게 만들기 
> 안티 리팩터링: 나쁜 코드를 딱 봐도 안좋아보이게 만드는 방법 
> - 코드가 보이는 방식만 수정

## 13.1 나쁜 코드에 대처하는 자세 
- 나쁜 코드를 어영부영 리팩터링해서 가리지는 말자 
  - 냅두는게 나을 때도 있음
  - 나쁜 코드를 식별 가능하게 만들자
    - 중간 품질의 코드는 알아채기 어려워도, 나쁜 코드는 알아채기가 쉽기 때문 
- 나쁜 코드가 생산될 때 체크해야 할 것
  - 프로젝트를 지속 가능한 속도로 진행하는가? 

## 13.2 깨끗한 코드와 레거시 코드로 분리 
- 더 나쁜 코드는 찾기가 더 쉬움 
- 눈에 띄게 나쁠 경우, 누군가가 수정할 가능성이 훨씬 더 높다 
  - 잘 만들 수 없다면 눈에 띄게 만들자 

## 13.3 나쁜 코드를 찾는 방법 
- 본 도서의 규칙을 활용하라 
- 코드 스멜을 찾아라 
- 순환 복잡도 지표를 사용하라 
  - 코드를 통과하는 경로의 수를 계산 (if, for...) 
  - 즉, 메서드의 제어 흐름에 대해 계산됨 
- 인지 복잡도를 파악하라
  - 코드를 읽는 동안 얼마나 많은 정보를 유지해야 하는가 
  - 사람이 무언가를 읽는 것이 얼마나 어려운지에 가까운 추정치 
  - 들여쓰기를 지표로써 사용할 수 있음 (들여쓰기가 얼마나 많이 되었는가?)
    - 우테코에서는 들여쓰기를 제한한다. (if문 내의 if문 금지, for문 안의 for문 금지...)

## 13.4 코드를 안전하게 나쁜 코드로 보이기 위한 규칙 
- 올바른 정보를 훼손하지 말 것 
  - 정보가 정확하다는 전제하에 기존에 있는 모든 정보를 보존해야 함 
  - ex: 메서드 이름은 좋은데 본문이 지저분하다면 이름을 바꾸지 말자. 부정확하거나 불필요한 주석과 같은 정보는 제거해도 됨. 
- 향후 리팩터링을 어렵게 만들지 말 것
  - 빈 줄로 컨텍스트를 구분하는 등, 리팩터링을 유도하는 것을 포함하여 모든 정보를 표시하자 
  - 가급적이면 향후 리팩터링을 더 쉽게 만들자 
- 결과를 한눈에 알 수 있을 것 
  - 깨끗한 코드와 구분할 수 있는 눈에 띄는 차이가 있음을 보장해야 함 


## 13.5 나쁜 코드를 나쁘게 보이기 위한 방법 
