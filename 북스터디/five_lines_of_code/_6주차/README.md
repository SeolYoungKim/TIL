# 9. 코드 삭제의 미학 
## 9.2 복잡성을 제거하기 위한 코드 삭제 
- 복잡성 
  - 도메인 복잡성
    - 도메인이 기본적으로 가지고있는 것 
    - 해결하려는 문제는 본질적으로 복잡하다 
  - 부수적 복잡성 
    - 기술적 무지로 인한 복잡성
    - 기술적 낭비로 인한 복잡성
    - 기술적 부채로 인한 복잡성
    - 기술적 방해물로 인한 복잡성


### 9.2.1 경험 부족으로 인한 기술적 무지 
- 불필요한 결합을 추가하지 않고도 문제를 해결할 수 있는 기술이 부족해서 발생 
- 기술적 우수성과 우수한 설계에 지속적으로 주의를 기울이면 민첩성이 향상된다
- 노력하자 
  - 책, 블로그, 콘퍼런스 등을 보면서 학습하기 
  - 공동 프로그래밍을 통해 지식을 공유하기
    - 모든 아이디어가 코드에 적용되기 전에 다른 사람의 두뇌를 거쳐야 한다 
  - 의도적인 연습을 통해 기술을 향상시키기


### 9.2.2 시간 압박으로 인한 기술적 낭비 
- 시간 압박...
  - 문제나 모델을 충분히 이해하지 못해서 테스트나 리팩터링을 건너 뜀
  - 기한을 맞추기 위해 프로세스를 우회 
- 개발자에게 모범 사례를 건너 뛸 기회가 전혀 없게 하자 
  - 프로젝트 관리자, 고객 및 기타 이해관계자에게 올바른 소프트웨어 구축이 필수임을 가르쳐야 함 
  - 브레이크나 에어백 테스트 없이 새 차를 3주 더 빨리 받을 수 있을 때, 그렇게 할 것인가? 


### 9.2.3 환경에 따른 기술적 부채 
- 기술적 무지와 낭비는 제거될 수 있으며, 제거되어야 하는게 맞음 
- 기술 부채는 일시적으로 차선의 해결책을 선택해서 이익을 얻는 것 
  - 의도적인 의사결정이나, **일시적임을 인지하자**
- 만료일이 있는 한, 본질적으로 잘못된 기술 부채는 없다 


### 9.2.4 성장에 따른 기술적 장애물 
- 기술적 장애물이란, 개발을 더디게 만드는 모든 것을 말함 
  - 문서, 테스트, 레거시 코드 등 
- "거기 두어도 아무런 방해가 되지 않는다"라는 말은 거짓말임 
  - 더이상 삭제할 것이 없을 때 까지 가능한 한 많은 것을 삭제하라 
  - 조금이라도 사용되지 않는 것은 사라져야 함 
  - 사용되지 않거나 불필요한 기능, 코드, 문서, 위키 페이지, 테스트, 환경 설정 플래그, 인터페이스, 버전 관리 시스템의 브랜치 등을 모두 삭제하자 
- 사용하지 않으면 기능은 퇴화한다 


## 9.3 친밀도에 따른 코드 분류 
- 우리가 잘 알고 있는 코드일수록 높은 친밀도
- 친밀도가 높은 코드를 삭제하는 것이, 이해를 먼저 해야 하는 코드를 삭제하는 것 보다 저렴하고 안전함 


## 9.4 레거시 시스템에서의 코드 삭제 
- 레거시 코드는 수정하기가 겁나는 코드다 

### 9.4.1 스트랭글러 패턴 
- 교살 패턴 
- 새로운 코드를 추가하고, 기존 코드를 삭제하는 방식
  - 이는 바로 삭제하는게 아니라, 기존 코드를 사용하던 부분을 모두 새로운 코드로 변경한 뒤, 사용되는 곳이 확실하게 없다고 판단될 때 삭제하는 것임 
  - IDE의 도움을 받자. 사용되는 곳을 찾아주는 기능이 있음. 사용되지 않을 경우, 사용되지 않는다고 표시가 되며 이럴 때 삭제해버리면 됨
- 이를 위해서는 테스트 코드가 필요하다 
- 많이 사용되는 부분은 점진적으로 마이그레이션하고, 사용되지 않는 부분들은 삭제하자 


## 9.5 동결된 프로젝트에서 코드 삭제 
- 동결된 프로젝트에는 데이터베이스 테이블, 통합, 서비스 등 코드 밖의 많은 항목이 포함될 수 있음
- 해당 내용은 크게 공감되지 않았음.. (이해도 못했음)


## 9.6 버전 관리에서 브랜치 삭제
- `main`에 병합된 브랜치는 삭제하자 
- 사용되지 않는 브랜치는 삭제하자 


## 9.7 코드 문서 삭제 
- 문서: 위키 페이지, Javadoc, 설계 문서, 튜토리얼 등... 
- 문서는 세 가지 조건을 충족해야 함 
  - 관련성: 올바른 질문에 답해야 함 
  - 정확성: 답은 정확해야 함 
  - 발견 가능성: 답을 찾을 수 있어야 함 
- 위 속성 중 하나라도 누락될 경우 문서의 가치가 크게 떨어짐
- 문서의 현행화는 중요하다
- 문서의 정확성을 유지하기 위해, 자동화된 테스트 케이스를 문서로 사용하는 방법이 있음 

### 9.7.1 문서화 하는 것이 의미가 있는지 여부를 결정하는 알고리즘
1. 문서화 대상이 자주 바뀌면 문서화해서 얻을 수 있는 것은 없음 
2. 드물게 사용하는 경우 문서화 
3. 그렇지 않고, 자동화할 수 있으면 자동화 
4. 그렇지 않으면, 외울 것 


## 9.8 테스트 코드 삭제 
- 개발을 방해하는 테스트 코드 삭제 
  - 신뢰를 주지 않는 테스트는 삭제한다 
- 복잡성을 줄이기 위해 코드를 리팩터링한다 
- 테스트 전문화로 속도를 높이자 

### 9.8.1 낙관적 테스트 삭제 
- 실패할 수 없는 테스트는 가치가 없음 
- 실패한 적 없는 테스트는 절대 신뢰하지 말라?
  - 꼭 실패를 해야만 하는가 ? 

### 9.8.2 비관적 테스트 삭제
- 항상 실패하는 테스트만 하면 경보 피로를 느껴 중대한 오류를 놓칠 가능성이 있음 

### 9.8.3 불안정 테스트 수정 또는 삭제 
- 항상 같은 결과를 내지 않는, 예측할 수 없는 레드 또는 그린 테스트 

### 9.8.4 복잡한 테스트를 제거하기 위한 리팩터링 
- 테스트하기 쉬운 코드로 만들자 
- 테스트가 코드보다 더 복잡하면, 코드가 잘못된 것인지 테스트가 잘못된 것인지 알 수 없다 
  - 테스트는 간결해야 한다 
  - 테스트를 리팩터링 해야 한다는 것 == 테스트 중인 코드에 적절한 아키텍처가 없다는 것 == 리팩터링을 해야한다는 신호

### 9.8.5 속도를 높이는 테스트 문화 
- E2E 테스트는 진행이 느릴 수 있고, 다른 테스트 실행 빈도에 영향을 미침 
  - 느린 테스트가 다른 테스트를 덜 자주 실행하게 만든다면, 개발에 지장을 준다 


## 9.9 설정 코드 삭제 
- 책에서 말하는 설정 코드가 뭘까...
- 완벽하게 만들 수 없다면 최소한 설정이 가능하게 만들어라
- 실험을 위한 설정
  - 테스트가 완료되는 즉시 제거하라는 알림을 생성하자 (A/B 테스트, 베타 테스트...를 위한 설정 코드)
- 과도기적인 설정
  - 레거시가 새로운 시스템으로 전환되는 경우
  - 단기적인 작업이 아님
  - 스트랭글러 패턴 등을 이용해서 점진적으로 전환하고, 사용되지 않는 오래된 부분은 제거하자 
- 영구적인 설정 
  - 사용량이 점차 증가하고, 유지보수가 간단한 경우가 이에 해당 
  - 사용량을 늘리지 않는 경우 삭제 

## 9.10 라이브러리 제거를 위한 코드 삭제 
- 서드파티 라이브러리 
  - 업데이트를 신경써야 함 
  - 사용에 최소한의 지식이 있어야 함 
  - 서드파티에 의존적인 코드가 됨
    - 예측 가능성을 잃음 

### 9.10.1 외부 라이브러리에 대한 의존도 제한 
- 신뢰할 수 있는 공급 업체만 사용해라 
- 자주 업데이트 해라 
- 사용하지 않는 라이브러리가 있으면 제거해라 
- 내부에서 구현하기가 쉬운 경우 직접 구현해라
  - 즉, 의존도를 낮추기 위해 노력해라 

## 9.11 작동 중인 기능에서 코드 삭제 
- 작동 중인 기능에 대해서도 비판적으로 판단한다
- 감당하지 못할 경우 제거한다 
  - 기능이 주는 이점 < 유지보수 비용 
- 비용을 줄이는 방법을 강구한다 
  - 사용되지 않는 것은 잠재력과는 상관 없이 비용일 뿐이다. 제거해라 


---

---

# 10. 코드 추가에 대한 두려움 떨쳐내기 
## 10.1 불확실성 받아들이기: 위험 감수
- 겁을 먹으면 효과적으로 일할 수 없다 
- 불확실한 영역이 우리가 배워야 할 부분이다. 위험에 뛰어들자! 

## 10.2 두려움 극복을 위한 스파이크 사용 
- 스파이크는 실험하고 버리는 코드 
  - 가설, 실험, 사용자 친화성 등을 테스트 
- 결국 저자는 "지식 습득"이 중요하다는 말을 하고싶은 것 같음 

## 10.3 낭비나 위험에 대한 두려움 극복을 위한 사용 시간 비율 지정 
- 비즈니스 로직을 작성하기도 전에...
  - 테스트 환경, 분기 전략, 저장소 구조, CI/CD 설정... 등에 너무 많은 시간을 소비하지 말자 
    - `낭비나 위험에 대한 두려움 > 산출물을 인도하려는 욕구` 를 암시함 
  - 이런 것들은 필요하나, 코드를 생산하지 않으면 가치가 없다 
  - 도구를 유지보수하거나 개발하는 데 너무 많은 노력이 소모 → 정작 중요한 것을 제공하지 못함 
- 지원 도구의 유지보수 및 개발과 같은 비기능 요구사항에는 개발자 시간의 20% 정도만 할당할 것을 권장함 
  - 프로덕션 코드보다 더 복잡해질 수 없음 
  - 즉, 프로덕션 코드보다 복잡한걸 만들지 말라 
    - ex: 테스트 코드. 테스트 코드가 쓸데없이 복잡하다면, 프로덕션 코드가 잘못된게 아닌지를 생각 해보자.
- 월~목: 기능 구현 / 금: 리팩터링, 실험, 자동화 등 부가 작업 

## 10.4 불완전성에 대한 두려움 극복을 위한 점진적 개선 
- 완벽한 코드는 없다 
- 무엇에 초점을 맞출 것인지, 그리고 어디에서 불완전함을 받아들일 것인지를 선택해야 한다 

## 10.5 복사 및 붙여넣기가 속도에 미치는 영향 
- 중복에 대해..
  - 유사성이 우연적인 것인지, 정말로 유사한 것인지를 판단해야 함 
- 코드 복제에 고려해야 할 두 가지 중요한 특성 
  - 코드를 공유하면, 사용되는 모든 위치에 영향을 미치기 쉬움 
    - 코드를 수정할 때 모든 위치를 수정해야 함
  - 코드의 여러 다른 위치에 동시에 영향을 줄 수 있음 
    - 코드상으로 관련이 없어 보이는 곳에서 손상을 일으킬 수 있음 
    - 공유 코드를 변경할 때마다 불변속성이 깨질 위험이 있음 

## 10.6 확장성을 통한 추가에 의한 변경 
- 일부 코드가 변경에 수용적이어야 하는 경우 확장 가능하게 만들어야 함 
- 변형이 발생하는 지점 
  - 코드가 더 복잡해짐 → 코드 흐름 이해가 어려워짐 → 수정이 더 어려워짐 
  - 모든 것을 확장 가능하게 만드는 것 → 코드를 불필요하게 복잡하게 만들어 버림  





