# 1. 리팩터링 리팩터링하기
## Introduction | 리팩터링에 요구되는 3요소 - "스킬", "문화", "도구" 
### 리팩터링에는 스킬이 필요하다 
- 어떤 코드가 잘못되었는지 파악하는 능력이 필요하다. 
- 잘못 되었음을 파악하여야 리팩터링을 할 수 있다.
- 주니어들은 코드 스멜을 육감같은 것으로 이해하는데(저도 그렇습니다), 이는 엄연한 스킬이다! 

### 리팩터링에는 개발 문화도 받쳐줘야 한다
- 리팩터링에 시간을 들이는 것을 권장하는 개발 문화가 있어야 한다. 
- 일반적으로 TDD의 red-green-refactor 순환 절차로 구현됨. -> 알아만 두자! 나중에 써먹을 날이 오지 않을까..


### 리팩터링에는 도구가 필요하다 
- 우리가 하는 리팩터링 작업이 안전하다는 것을 보장해야 한다.
- 이를 실현할 수 있는 가장 일반적인 방법은 "자동화된 테스트"이다. 
- 하지만 효과적으로 테스트를 하는 것을 배우기는 매우 어렵다. 

## 1.1 리팩터링이란 무엇인가? 
### 정의 
- 기능을 변경하지 않고 코드를 변경하는 것 

### 리팩터링을 해야하는 이유 
- 코드를 더 빠르게 만들기 위함 
- 더 작은 코드를 만들기 위함 
- 코드를 더 일반적으로 만들거나, 재사용 가능하게 하기 위함 
- **코드의 가독성을 높이고, 유지보수를 용이하게 하기 위함**  ->  가장 중요! 

### 좋은 코드 
- 사람이 읽기 쉽고, 유지보수가 용이하며, 의도대로 잘 동작하는 코드 
  - 가독성을 높이면 : 새로운 기능을 구현하기 위한 시간 확보 
  - 유지보수가 용이해지면 : 버그가 줄어들고 수정이 쉬워짐


## 1.2 스킬: 무엇을 리팩터링할 것인가?
### 코드 스멜 
- 코드가 나쁘다는 것을 암시
- 추상적이고 어려워 보는 감각을 키우는 데 시간이 걸림
  - 본 도서에서는 다른 접근 방식을 취해 "규칙을 제안"함 -> 규칙이 사용하기 쉽고 빠르게 배울수 있기 때문 
  - 코드 스멜의 예시 : "함수는 한 가지 작업을 수행해야 함"
  - 본 도서에서 제안하는 규칙의 예시 : "함수는 다섯 줄 이내로 구현하도록 제한함"


## 1.3 문화: 리팩터링은 언제? 
> 리팩터링은 샤워하는 것과 같다. -켄트 백
### 리팩터링은 정기적으로 
- 가능하면 일상 업무에 통합하는 것이 좋음
  - 정기적인 리팩터링이 효과적이고 비용이 적게 듦 

### 6단계 작업 절차 
1. 탐색 
    - 신속하게 구현하여 고객이 무엇을 필요로 하는지 확인 (실험!) 
2. 명세화
   - 무엇을 만들지를 명세화 (자동화된 테스트)
3. 구현
    - 코드를 구현 
4. 테스트
    - 코드가 명세를 따르는지를 확인
5. 리팩터링
    - 코드를 전달하기 전에 **다음 사람이 쉽게 작업할 수 있는지를 확인**
    - 메서드를 하나 선택 -> 메서드가 규칙을 위반했는지 확인 -> 위반한 경우 리팩터링 패턴을 찾음 -> 리팩터링 수행 
6. 전달
    - PR(Pull Request)

### 레거시 시스템에서의 리팩터링
> 우선 변경하기 쉽게 만든 후 변경하라 -켄트 백
- 가장 먼저, 새 코드를 쉽게 추가할 수 있게 만들 것


### 리팩터링의 단점 
- 정기적으로 하지 않을 경우 시간이 오래 걸릴 수 있음 (내 상황...)
- 리팩터링이 필요하지 않은 경우 
  - 한 번 실행하고 삭제할 코드 
  - 폐기 전 유지보수 모드에 있는 코드 
  - 엄격한 성능 요구사항이 있는 코드 


## 1.4 도구: (안전한) 리팩터링 방법
### 자동화된 테스트 
- 안심하고 빠르게 리팩터링 가능 

### 테스트 스끼리 부족한 경우... 
- 도구에 더 많이 의존 해보자 
  - 상세하고 단계별로 구조화된 리팩터링 패턴 (본 도서를 말하는듯)
    - 리팩터링 패턴이 섬세하게 설계되고, 작은 단계로 수행되면 아무런 문제없이 리팩터링을 할 수 있을것임 
  - 버전 관리(Git)
  - 컴파일러 

---

---

# 2. 리팩터링 깊게 들여다보기
## 2.1 가독성 및 유지보수성 향상 
> 명심! 리팩터링이란 **코드가 하는 일을 변경하지 않고** 더 나은 코드를 만드는 것이다. 

### 가독성 
- 의도를 전달하기 위한 코드의 성질 
  - 코드가 반드시 의도대로 동작한다는 전제조건이 있어야 함 
- 의도를 전달하는 방법
  - 컨벤션
  - 주석 
  - 변수, 메서드, 클래스, 파일 이름 지정 
  - 공백 


### 유지보수성 
- 얼마나 많은 후보를 조사해야 하는지를 나타내는 표현 
  - 일부 기능을 변경 -> 새 코드를 어디에 놓을지 후보 위치(context)를 조사 -> 코드가 무슨 일을 하는지 파악 -> 안전하고 빠르게, 쉽게 수정할 수 있는 방법 찾기 
- 살펴봐야 할 코드가 많을수록 시간이 더 오래 걸리고 무언가를 놓칠 가능성이 높다
  - 유지보수성은 변경 시 발생하는 위험과 밀접하게 관련돼 있음
  - 조사 단계에 시간이 오래걸린다 == 유지보수성이 나쁘다는 징후 -> 개선 필요

####  취약한 시스템
- 무언가를 수정했을 때 관련 없는 다른 곳에서 문제가 발생하는 시스템
- 변경 여파가 매우 큰 상태 

#### 불변 속성(invariant)
- "이 숫자는 절대로 음수일 수 없습니다."와 같은 속성 이라는데... 
- 내가 이해한 바로는
  - "변하지 않는다고 생각한 어떠한 속성"을 의미함 
  - 그러나 해당 속성이 "변할 가능성은 언제든지 존재"함
  - 특히, 해당 속성을 전역으로 둔다면, 어디서 해당 값을 참조하고, 변화시켜버릴 가능성이 있음.
  - 그러니 불변 속성이라고 생각되는 것은 **범위를 제한**하여 **함께 변하는 것은 함께 두어야**한다.
  - 즉, "응집도를 높여야 한다."는 말을 어렵게 풀어쓴 것이라고 이해하였음. 

### 코드가 하는 일을 바꾸지 않고 유지보수하기 
- 코드를 **블랙박스**로 생각할것 
  - 외부에 영향을 주지 않고, 내부의 모든 작업을 변경할 수 있다고 생각해야 함 
  - 즉, 값을 입력할 때 **리팩터링 전과 후에 동일한 결과를 얻어야**함 
- 리팩터링을 할 때, **블랙박스의 경계를 고려**하자 
  - 어느 정도의 코드를 변경할 것인가
  - 내가 변경하는 것을 다른 사람이 변경하지 못하도록 하자


## 2.2 속도, 유연성 및 안정성 확보 
- 변수명도 중요한데, 좋은 메서드명을 지어야 한다.
### 상속보다는 컴포지션
- 함께 변하는 것이 함께 있지 않는 경우(**범위가 제한되지 않은 불변 속성**) 유지보수가 어렵다. 
- 상속은 부모 클래스에 특정 동작이 추가되어도, 자식 클래스에서 알 수 없다. (컴파일 에러가 발생하지 않음)
  - **구현을 강제할 수 없어, 의도와 다르게 동작할 위험이 증가**한다.
- 컴포지션을 중심으로 만들어진 시스템은 다른 방식보다 더 깔끔하게 코드를 결합하고 재사용할 수 있다. 
  - 레고 블록을 가지고 노는것과 같다.


### 컴포지션은 "추가"로 변경이 가능하다
- 기존 기능에 영향을 주지 않고 기능을 추가하거나 변경할 수 있다  
  - 변경 포인트가 제한된다
  - OCP(OpenClosedPrincipal)를 지킬 수 있다 
    - 확장에 열려있고, 변경엔 닫혀있다는 규칙
- 불변 속성의 범위가 제한되어 안정성이 향상된다

```java
// 기존 기능에 영향을 주지 않음 
class GuGuClass {
    public Pigeon pigeon;

    public GuGuClass() {
        pigeon = new Pigeon();
    }

    public void newFunction() {
        // GuGuClass에 새로운 기능이 추가되어도 Pigeon 클래스에는 영향이 없다.
    }
}
```

## 2.3 리팩터링과 일상 업무 
### 기술 부채
- 열악한 소프트웨어 아키텍처에 대한 이자가 붙는 것을 의미
  - 리팩터링하지 않고 코드를 전달하기만 하면 다른 프로그래머의 시간을 빼앗는다
- 일상 속 리팩터링(강조!!)
  - 레거시 시스템은 변경 전에 먼저 리팩터링하자 (새로운 코드를 추가하기 쉽게!)
  - 코드를 변경한 후에도 리팩터링하자 

## 2.4 소프트웨어 분야에서 "도메인" 정의하기 
### 도메인
- 실제 세계의 구성 요소
- 소프트웨어는 실생활의 특정 측면을 모델링한 것 
  - 소프트웨어와 대응되는 실세계는 항상 존재함
- 도메인에는 아래의 것들이 존재한다 
  - 사용자
  - 전문가
  - 고유한 용어
  - 고유한 문화 
- 프로그래밍 언어는 모호성을 허용하지 않는다 
  - 전문가 조차도 새로운 코너 케이스(corner case)를 찾아야함 
- 결과적으로 프로그래밍은 의사소통과 학습에 관한 것임 