# 1. 리팩터링 리팩터링하기
## Introduction | 리팩터링에 요구되는 3요소 - "스킬", "문화", "도구" 
### 리팩터링에는 스킬이 필요하다 
- 어떤 코드가 잘못되었는지 파악하는 능력이 필요하다. 
- 잘못 되었음을 파악하여야 리팩터링을 할 수 있다.
- 주니어들은 코드 스멜을 육감같은 것으로 이해하는데(저도 그렇습니다), 이는 엄연한 스킬이다! 

### 리팩터링에는 개발 문화도 받쳐줘야 한다
- 리팩터링에 시간을 들이는 것을 권장하는 개발 문화가 있어야 한다. 
- 일반적으로 TDD의 red-green-refactor 순환 절차로 구현됨. -> 알아만 두자! 나중에 써먹을 날이 오지 않을까..


### 리팩터링에는 도구가 필요하다 
- 우리가 하는 리팩터링 작업이 안전하다는 것을 보장해야 한다.
- 이를 실현할 수 있는 가장 일반적인 방법은 "자동화된 테스트"이다. 
- 하지만 효과적으로 테스트를 하는 것을 배우기는 매우 어렵다. 

## 1.1 리팩터링이란 무엇인가? 
### 정의 
- 기능을 변경하지 않고 코드를 변경하는 것 

### 리팩터링을 해야하는 이유 
- 코드를 더 빠르게 만들기 위함 
- 더 작은 코드를 만들기 위함 
- 코드를 더 일반적으로 만들거나, 재사용 가능하게 하기 위함 
- **코드의 가독성을 높이고, 유지보수를 용이하게 하기 위함**  ->  가장 중요! 

### 좋은 코드 
- 사람이 읽기 쉽고, 유지보수가 용이하며, 의도대로 잘 동작하는 코드 
  - 가독성을 높이면 : 새로운 기능을 구현하기 위한 시간 확보 
  - 유지보수가 용이해지면 : 버그가 줄어들고 수정이 쉬워짐


## 1.2 스킬: 무엇을 리팩터링할 것인가?
### 코드 스멜 
- 코드가 나쁘다는 것을 암시
- 추상적이고 어려워 보는 감각을 키우는 데 시간이 걸림
  - 본 도서에서는 다른 접근 방식을 취해 "규칙을 제안"함 -> 규칙이 사용하기 쉽고 빠르게 배울수 있기 때문 
  - 코드 스멜의 예시 : "함수는 한 가지 작업을 수행해야 함"
  - 본 도서에서 제안하는 규칙의 예시 : "함수는 다섯 줄 이내로 구현하도록 제한함"


## 1.3 문화: 리팩터링은 언제? 
> 리팩터링은 샤워하는 것과 같다. -켄트 백
### 리팩터링은 정기적으로 
- 가능하면 일상 업무에 통합하는 것이 좋음
  - 정기적인 리팩터링이 효과적이고 비용이 적게 듦 

### 6단계 작업 절차 
1. 탐색 
    - 신속하게 구현하여 고객이 무엇을 필요로 하는지 확인 (실험!) 
2. 명세화
   - 무엇을 만들지를 명세화 (자동화된 테스트)
3. 구현
    - 코드를 구현 
4. 테스트
    - 코드가 명세를 따르는지를 확인
5. 리팩터링
    - 코드를 전달하기 전에 **다음 사람이 쉽게 작업할 수 있는지를 확인**
    - 메서드를 하나 선택 -> 메서드가 규칙을 위반했는지 확인 -> 위반한 경우 리팩터링 패턴을 찾음 -> 리팩터링 수행 
6. 전달
    - PR(Pull Request)

### 레거시 시스템에서의 리팩터링
> 우선 변경하기 쉽게 만든 후 변경하라 -켄트 백
- 가장 먼저, 새 코드를 쉽게 추가할 수 있게 만들 것


### 리팩터링의 단점 
- 정기적으로 하지 않을 경우 시간이 오래 걸릴 수 있음 (내 상황...)
- 리팩터링이 필요하지 않은 경우 
  - 한 번 실행하고 삭제할 코드 
  - 폐기 전 유지보수 모드에 있는 코드 
  - 엄격한 성능 요구사항이 있는 코드 


## 1.4 도구: (안전한) 리팩터링 방법
### 자동화된 테스트 
- 안심하고 빠르게 리팩터링 가능 

### 테스트 스끼리 부족한 경우... 
- 도구에 더 많이 의존 해보자 
  - 상세하고 단계별로 구조화된 리팩터링 패턴 (본 도서를 말하는듯)
    - 리팩터링 패턴이 섬세하게 설계되고, 작은 단계로 수행되면 아무런 문제없이 리팩터링을 할 수 있을것임 
  - 버전 관리(Git)
  - 컴파일러

## 추가 
### 켄트백 
- 테스트가 전제에 깔려있어야 하는 것을 기억하자 

### 리팩토링 내성
- 블라디미르의 단위테스트라는 책을 읽어봅시다 

---

---

# 2. 리팩터링 깊게 들여다보기
## 2.1 가독성 및 유지보수성 향상 
> 명심! 리팩터링이란 **코드가 하는 일을 변경하지 않고** 더 나은 코드를 만드는 것이다. 

### 가독성 
- 의도를 전달하기 위한 코드의 성질 
  - 코드가 반드시 의도대로 동작한다는 전제조건이 있어야 함 
- 의도를 전달하는 방법
  - 컨벤션
  - 주석 
  - 변수, 메서드, 클래스, 파일 이름 지정 
  - 공백 


### 유지보수성 
- 얼마나 많은 후보를 조사해야 하는지를 나타내는 표현 
  - 일부 기능을 변경 -> 새 코드를 어디에 놓을지 후보 위치(context)를 조사 -> 코드가 무슨 일을 하는지 파악 -> 안전하고 빠르게, 쉽게 수정할 수 있는 방법 찾기 
- 살펴봐야 할 코드가 많을수록 시간이 더 오래 걸리고 무언가를 놓칠 가능성이 높다
  - 유지보수성은 변경 시 발생하는 위험과 밀접하게 관련돼 있음
  - 조사 단계에 시간이 오래걸린다 == 유지보수성이 나쁘다는 징후 -> 개선 필요

####  취약한 시스템
- 무언가를 수정했을 때 관련 없는 다른 곳에서 문제가 발생하는 시스템
- 변경 여파가 매우 큰 상태 

#### 불변 속성(invariant)
- "이 숫자는 절대로 음수일 수 없습니다."와 같은 속성 이라는데... 
- 내가 이해한 바로는
  - "변하지 않는다고 생각한 어떠한 속성"을 의미함 
  - 그러나 해당 속성이 "변할 가능성은 언제든지 존재"함
  - 특히, 해당 속성을 전역으로 둔다면, 어디서 해당 값을 참조하고, 변화시켜버릴 가능성이 있음.
  - 그러니 불변 속성이라고 생각되는 것은 **범위를 제한**하여 **함께 변하는 것은 함께 두어야**한다.
  - 즉, "응집도를 높여야 한다."는 말을 어렵게 풀어쓴 것이라고 이해하였음. 

### 코드가 하는 일을 바꾸지 않고 유지보수하기 
- 코드를 **블랙박스**로 생각할것 
  - 외부에 영향을 주지 않고, 내부의 모든 작업을 변경할 수 있다고 생각해야 함 
  - 즉, 값을 입력할 때 **리팩터링 전과 후에 동일한 결과를 얻어야**함 
- 리팩터링을 할 때, **블랙박스의 경계를 고려**하자 
  - 어느 정도의 코드를 변경할 것인가
  - 내가 변경하는 것을 다른 사람이 변경하지 못하도록 하자


## 2.2 속도, 유연성 및 안정성 확보 
- 변수명도 중요한데, 좋은 메서드명을 지어야 한다.
### 상속보다는 컴포지션
- 함께 변하는 것이 함께 있지 않는 경우(**범위가 제한되지 않은 불변 속성**) 유지보수가 어렵다. 
- 상속은 부모 클래스에 특정 동작이 추가되어도, 자식 클래스에서 알 수 없다. (컴파일 에러가 발생하지 않음)
  - **구현을 강제할 수 없어, 의도와 다르게 동작할 위험이 증가**한다.
- 컴포지션을 중심으로 만들어진 시스템은 다른 방식보다 더 깔끔하게 코드를 결합하고 재사용할 수 있다. 
  - 레고 블록을 가지고 노는것과 같다.


### 컴포지션은 "추가"로 변경이 가능하다
- 기존 기능에 영향을 주지 않고 기능을 추가하거나 변경할 수 있다  
  - 변경 포인트가 제한된다
  - OCP(OpenClosedPrincipal)를 지킬 수 있다 
    - 확장에 열려있고, 변경엔 닫혀있다는 규칙
- 불변 속성의 범위가 제한되어 안정성이 향상된다

```java
// 기존 기능에 영향을 주지 않음 
class GuGuClass {
    public Pigeon pigeon;

    public GuGuClass() {
        pigeon = new Pigeon();
    }

    public void newFunction() {
        // GuGuClass에 새로운 기능이 추가되어도 Pigeon 클래스에는 영향이 없다.
    }
}
```

## 2.3 리팩터링과 일상 업무 
### 기술 부채
- 열악한 소프트웨어 아키텍처에 대한 이자가 붙는 것을 의미
  - 리팩터링하지 않고 코드를 전달하기만 하면 다른 프로그래머의 시간을 빼앗는다
- 일상 속 리팩터링(강조!!)
  - 레거시 시스템은 변경 전에 먼저 리팩터링하자 (새로운 코드를 추가하기 쉽게!)
  - 코드를 변경한 후에도 리팩터링하자 

## 2.4 소프트웨어 분야에서 "도메인" 정의하기 
### 도메인
- 실제 세계의 구성 요소
- 소프트웨어는 실생활의 특정 측면을 모델링한 것 
  - 소프트웨어와 대응되는 실세계는 항상 존재함
- 도메인에는 아래의 것들이 존재한다 
  - 사용자
  - 전문가
  - 고유한 용어
  - 고유한 문화 
- 프로그래밍 언어는 모호성을 허용하지 않는다 
  - 전문가 조차도 새로운 코너 케이스(corner case)를 찾아야함 
- 결과적으로 프로그래밍은 의사소통과 학습에 관한 것임

## 내용 추가 
### 있어야 하는 것  
- 코드리뷰 문화가 있어야 한다 
- 리딩할 사람이 필요하다
- 내 생각을 거리낌없이 말할 수 있는 문화가 있어야 한다
- 틀린게 아니라 다르다. 이를 인정하자 -> 열린 자세가 중요
- 비즈니스로직은 잘 모르더라도, 코드 스멜정도는 알아챌 수 있다 
  - 네이밍 컨벤션이 안 맞는다거나...
  - 트랜잭션 처리에 문제가 될 수 있다거나... 

---

---

# 3. 긴 코드 조각내기 
## Introduction
- DRY(똑같은 일 두번x), KISS(단순함을 지킬 것) 원칙을 따라도 코드는 쉽게 지저분해지고 혼란스러워진다 
  - 메서드가 여러 가지 다른 일을 수행하기 때문 -> 단일 책임 원칙 위배 
  - 낮은 수준의 원시 연산을 사용 (`arr.length`와 같은) 
  - 사람이 읽을 수 있는 텍스트 부족 (주석, 적절한 메서드명...)

## 3.1 첫 번쨰 규칙: 왜 다섯줄인가?
### 다섯 줄 제한 
- 메서드는 ` `(공백), `{`, `}`를 제외하고 5줄 이상이 되어서는 안됨 
- 코드 한줄 
  - 하나의 `if`, `for`, `while` 또는 `;`으로 끝나는 모든 것
  - 할당, 메서드 호출, `return`과 같은 것 
- 메서드 추출 리팩터링 기법을 이용 

### 스멜 
- 메서드가 길다는 것 자체가 스멜이다 
- 메서드는 한 가지 작업만 해야한다 
- 한 가지 작업에 5줄이 적절하다고 판단 (본 도서에서...)

### 의도 
- 메서드 이름으로 코드의 의도를 전달하자 
- 20줄인 하나의 메서드 보다, 각각 5줄의 코드가 있는 4개의 메서드가 더 이해하기 쉽다


## 3.2 함수 분해를 위한 리팩터링 패턴 
### 그룹화 
- 코드의 형태를 살피고, 그룹화를 해서 구조에 집중 해보자 
- 함수 전체를 소화하기 보다, 작게 잘라서 이해하기 쉽게 하나씩 처리하자 
  - like 분할 정복 기법 

### 메서드 추출
- 메서드 일부를 취해서 자체 메서드로 추출 (Intellij의 option + cmd + m 애용)
- `if`의 일부 분기만 `return`문을 가진 경우 
  - 메서드의 끝에서 시작해 위로 작업 해나가자 (고급 팁이라고..)

```java
// before
class ThisIsClass {
  public String trashMethod(int num) {
    if (num == 1) {
      return "일";
    }

    if (num == 10) {
      return "십";
    }

    if (num == 5) {
      System.out.println("메롱");
    }
  }
}

// after : 이런 식으로 작업하란건가 
class ThisIsClass {
  public String trashMethod(int num) {
    // trashMethod에는 결과적으로 분기가 return문이 있는 분기만 남음 
    if (num == 1) {
      return "일";
    }

    if (num == 10) {
      return "십";
    }

    merong(num);  // 분기는 추출한 메서드 내부로 이동 
  }

  private void merong(int num) {
    if (num == 5) {
      System.out.println("메롱");
    }
  }
}
```

- 책에 나오는 절차들은 생략
  - IDE를 이용하는 게 정신 건강에 좋을 것 같아요.. 
- 내가 생각하는 핵심은..
  - 그룹화를 하는 것! -> 그룹화를 하고 그룹마다 메서드를 추출해서 작게 잘라보자


## 3.3 추상화 수준을 맞추기 위한 함수 분해 
### 규칙: 호출 또는 전달, 한 가지만 수행할 것
#### 정의 
- 함수 내에서는 아래의 작업을 할 수 있다
  - 객체의 메서드를 호출
  - 객체를 인자로 전달
- 하지만, 둘을 섞어서 사용해서는 안 된다

#### 설명
- 동일한 추상화 수준을 유지해야 가독성이 좋아진다
  - 낮은 수준의 작업과 높은 수준의 작업이 공존해서는 안된다 
```java
class ThisIsClass {
  double calculateAverage(int[] numbers) {
    return (double) sum(numbers) / size(numbers);  // 동일한 추상화 수준으로 구성된 메서드 
  }

  private int sum(int[] numbers) {
    return Arrays.stream(numbers).sum();
  }

  private int size(int[] numbers) {
    return numbers.length;  // 저수준의 호출을 메서드로 추출
  }
}
```

#### 스멜
- 함수의 내용은 동일한 추상화 수준에 있어야 한다 
  - 이는 스멜이다. 하지만 찾아내는 방법이 명확하지 않다
  - 본 도서에서는 이를 "메서드 호출"과 "인자로 전달"하는 것을 구분하는 것을 규칙으로 삼은 것 같다

#### 의도 
- 메서드 내부의 추상화 수준을 동일하게 유지하는 것이 목적!


## 3.4 좋은 함수 이름의 속성 
### 좋은 이름
- 정직함
  - 함수의 의도를 설명해야 함
- 완전함
  - 함수가 하는 모든 것을 담음 
- 도메인에서 일하는 사람이 이해할 수 있어야 함
  - 도메인에서 사용하는 단어를 사용할 것 


## 3.5 너무 많은 일을 하는 함수 분리하기
### 내가 이해하기로는..
- 단일 책임 원칙을 지키는 방향으로 개선하는 느낌으로 작업을 수행하는 것 같음 

### 규칙: if문은 함수의 시작에만 배치하라 
#### 정의
- if문은 함수의 첫 번째 항목이어야 함 

#### 설명 
- 함수는 한 가지 일만 해야 함
  - 무언가를 확인하는 것 == 한 가지 일
  - if문은 무언가를 확인한다 == 한 가지 일 
  - 그러므로 if문 후에는 아무것도 해서는 안 됨 
- `else`문은 코드 구조의 일부로 본다. `if`문과 하나의 컨텍스트로 보는 것
  - 동작과 구조는 밀접하게 연관 돼있음  
  - 리팩터링 할 때 동작은 변경해서는 안되므로 구조 또한 변경해서는 안됨 
```java
class ThisIsClass {
  void reportPrimes(int number) {
    for (int i = 0; i < number; i++) {  // 반복을 수행한다.
      reportIfPrime(number);
    }
  }

  private void reportIfPrime(int number) {
    if (isPrime(number)) {  // 소수인지 체크한다.
      System.out.printf("%d is prime.\n", number);
    }
  }

  private boolean isPrime(int number) {
    // 대충 소수를 판별하는 로직 (귀찮아서 구현 안한거 맞음)
    return /* true or false */;
  }
}
```

#### 스멜
- 함수가 한 가지 이상의 작업을 수행하는 스멜을 방지

#### 의도 
- `else`, `else if`는 `if`문과 분리할 수 없는 원자 단위로 봄 

## 내용 추가 
### 마틴 파울러의 리팩터링 책
- 과 결이 같다 
- 같이 읽어봐도 좋을 듯 