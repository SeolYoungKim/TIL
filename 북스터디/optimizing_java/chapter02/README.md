# 02. JVM 이야기 
## 클래스 로더 
- 부트스트랩 클래스 로더 
  - Object, Class, ClassLoader 로드 
- 확장 클래스 로더 
  - 클래스 로딩 작업을 부모에게 이관 (부모=부트스트랩 클래스 로더)
  - 특정 OS나 플랫폼에 네이티브 코드 제공 
- 애플리케이션 클래스 로더
  - 사용자가 정의한 클래스를 로딩
  - Lazy하게 사용 시점에 로딩함 
    - JVM 웜업이 필요한 이유 

## Java의 클래스 로드 방법 
- 처음보는 새 클래스를 Dependency에 로드 
  - 찾을 때 까지 부모 클래스 로더에게 위임. 결국 못찾을 경우 ClassNotFoundException 발생
    - 애플리케이션 클래스 로더가 못 찾으면 
        - 확장 클래스 로더에 위임 
          - 확장 클래스 로더가 못 찾으면 
            - 부트스트랩 클래스 로더에 위임 
              - 부트스트랩 클래스 로더가 못 찾으면 
                - ClassNotFoundException 발생


- Java는 클래스를 로드할 때 Class 객체를 생성한다 
  - 똑같은 Class 객체를 **서로 다른 클래스 로더가 두 번 로드할 가능성**이 존재함 
  - Class객체의 정보
    - FQCN(Fully Qualified Class Name): 패키지명 + 클래스명 
    - 자신을 로드한 클래스 로더 
      - 이 때문에 두 번 로드될 가능성이 있는 것임 


## 자바의 바이트 코드 
- `*.java`를 `javac` 컴파일러가 `*.class`로 변환함
- `*.class`는 바이트 코드임 
  - 특정 컴퓨터 아키텍처에 종속되지 않음 (머신 코드가 아님) 
  - JVM이 이해할 수 있는 코드 
    - JVM은 바이트 코드를 해석해서 실행함


## 컴파일러
| JIT(Just-In-Time)                                                                   | AOT(Ahead-Of-Time)                                 |
|-------------------------------------------------------------------------------------|----------------------------------------------------|
| - 런타임에 기계어로 번역<br/> - 런타임 시 최적화(인터프리터로 실행된 정보 기반으로 최적화)<br/> - 동적 인라이닝, 가상 호출 사용 가능 | - 실행 전에 기계어로 번역 <br/> - 컴파일에 많은 시간이 소요되나, 빠른 실행 속도 |



